#!/usr/bin/env python3

import glob
import os
import re
import subprocess
from typing import Any, NamedTuple

import c2cciutils.lib.docker
import json5
import multi_repo_automation as mra
import multi_repo_automation.commented_yaml as mra_yaml
import ruamel.yaml.comments
import ruamel.yaml.scalarstring
import tomlkit.items
import yaml as py_yaml
from packaging import version

# if os.path.exists(".github/renovate.json5"):
# if mra.run(["grep", "text", ".github/renovate.json5"], exit_on_error=False).returncode != 0: # not found
# if mra.git_grep(r"\<text\>"]): # found
# if mra.run(["git", "ls-files", "**/*.txt"], stdout=subprocess.PIPE).stdout.strip() != b"": # found
# mra.edit("file")
# input()


class Config:
    _values: dict[str, Any] = {}
    _enabled: list[str] = []
    _disabled: list[str] = []

    def __init__(self) -> None:
        self.repo = mra.get_repo_config()
        self.arguments = mra.get_arguments()

        if os.path.exists(".github/ci-upgrade.yaml"):
            with open(".github/ci-upgrade.yaml", encoding="utf-8") as f:
                upgrade_config = py_yaml.load(f.read(), Loader=py_yaml.SafeLoader)
                self._values = upgrade_config.get("values", {})
                self._enabled = upgrade_config.get("enabled", [])
                self._disabled = upgrade_config.get("disabled", [])

    def value(self, name: str, default: Any = None) -> Any:
        return self._values.get(name, default)

    def enabled(self, name: str, default: bool) -> bool:
        if name in self._enabled:
            return True
        if name in self._disabled:
            return False
        return default


class TaskEnv(NamedTuple):
    c2cciutils_version: version.Version
    use_python: bool
    use_pypi: bool
    use_docker: bool
    use_helm: bool
    has_config: bool
    has_stabilization_branches: bool
    on_stabilization_branches: bool
    gopass: bool
    token: str
    config: Config


def _canonicalize_workflow(workflow: mra.EditYAML) -> None:
    new_data = []
    for key in ["name", "on", "permissions", "env"]:
        if key in workflow:
            new_data.append((key, workflow[key]))

    new_data += [e for e in workflow.items() if e[0] not in ("name", "on", "permissions", "env", "jobs")]

    if "jobs" in workflow:
        new_data.append(("jobs", workflow["jobs"]))

    workflow.data = ruamel.yaml.comments.CommentedMap(new_data)

    for key in ["name"]:
        workflow.data.ca.items[key] = [
            None,
            None,
            ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
            None,
        ]

    for key in ["on", "permissions", "env", "jobs"]:
        workflow.data.ca.items[key] = [
            None,
            [ruamel.yaml.CommentToken("\n", ruamel.yaml.error.CommentMark(0), None)],
            None,
            None,
        ]

    for name, job in workflow["jobs"].items():
        new_data = []
        for key in ["name", "runs-on", "timeout-minutes", "if", "concurrency", "needs"]:
            if key in job:
                new_data.append((key, job[key]))

        new_data += [
            e
            for e in job.items()
            if e[0]
            not in (
                "name",
                "runs-on",
                "timeout-minutes",
                "if",
                "concurrency",
                "needs",
                "strategy",
                "env",
                "steps",
            )
        ]

        for key in ["strategy", "env", "steps"]:
            if key in job:
                new_data.append((key, job[key]))

        job = ruamel.yaml.comments.CommentedMap(new_data)
        workflow["jobs"][name] = job

        for key in reversed(["name", "runs-on", "timeout-minutes", "if", "concurrency", "needs"]):
            if key in job:
                job.ca.items[key] = [
                    None,
                    None,
                    ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
                    None,
                ]
                break

        for key in reversed(["strategy", "env"]):
            if key in job:
                job.ca.items[key] = [
                    None,
                    None,
                    ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
                    None,
                ]


def _create_labels(task_env: TaskEnv) -> None:
    mra.gh(
        "label",
        "create",
        "--force",
        "dependencies",
        "--color=0075ca",
        "--description=Update the dependencies",
    )
    if task_env.config.enabled("pullRequestWelcome", False):
        mra.gh(
            "label",
            "create",
            "--force",
            "pull request welcome",
            "--color=6622BB",
            "--description=A pull request is welcome to fix this issue",
        )


def _set_schema_config(task_env: TaskEnv) -> None:
    if os.path.exists("ci/config.yaml"):
        with mra.Edit("ci/config.yaml") as ci_config:
            data = ci_config.data.split("\n")
            if ci_config.data.startswith(
                "# yaml-language-server: $schema=https://raw.githubusercontent.com/camptocamp/c2cciutils"
            ):
                data = data[1:]

            while data and not data[0].strip():
                data = data[1:]

            data = [
                "# yaml-language-server: $schema=https://raw.githubusercontent.com/camptocamp/"
                f"c2cciutils/{task_env.c2cciutils_version}/c2cciutils/schema.json",
                "",
                *data,
            ]

            ci_config.data = "\n".join(data)


def _upgrade_ubuntu(task_env: TaskEnv) -> None:
    del task_env

    for workflow_file in mra.run(
        ["git", "ls-files", ".github/workflows/*.yaml"], stdout=subprocess.PIPE
    ).stdout.split("\n"):
        if workflow_file:
            with mra.EditYAML(workflow_file) as yaml:
                for job in yaml["jobs"].values():
                    if job.get("runs-on", "").startswith("ubuntu-"):
                        job["runs-on"] = "ubuntu-22.04"


def _update_main_workflow(task_env: TaskEnv) -> None:
    if not os.path.exists(".github/workflows/main.yaml") and os.path.exists(".github/workflows/ci.yaml"):
        os.rename(".github/workflows/ci.yaml", ".github/workflows/main.yaml")
    if os.path.exists(".github/workflows/main.yaml"):
        with mra.EditYAML(".github/workflows/main.yaml") as yaml:
            if not task_env.on_stabilization_branches:
                env = yaml.setdefault("env", {})
                if "HAS_SECRETS" not in env:
                    env["HAS_SECRETS"] = "${{ secrets.HAS_SECRETS }}"

                    if hasattr(env, "ca"):
                        env.ca.items.clear()
                        env.ca.items["HAS_SECRETS"] = [
                            None,
                            None,
                            ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
                            None,
                        ]

                for job in yaml["jobs"].values():
                    has_pip_login = False
                    has_docker_login = False
                    publish_index = -1

                    for index, step in enumerate(job["steps"]):
                        if task_env.c2cciutils_version >= version.parse("1.6.0"):
                            if step.get("run", "") == "c2cciutils-checks":
                                step["name"] = "Print environment information"
                                step["run"] = "c2cciutils-env"
                                value = None
                                if "env" in step:
                                    if step["env"].ca.items:
                                        value = list(step["env"].ca.items.values())[-1][2].value
                                    del step["env"]
                                step["env"] = {"GITHUB_EVENT": "${{ toJson(github) }}"}
                                job["steps"].ca.items[index] = [
                                    None,
                                    None,
                                    [
                                        ruamel.yaml.CommentToken(
                                            value or "\n\n", ruamel.yaml.error.CommentMark(0), None
                                        )
                                    ],
                                    None,
                                ]
                        else:
                            if step.get("run", "") == "c2cciutils-checks":
                                if not task_env.gopass:
                                    env = step.setdefault("env", {})
                                    env["SNYK_TOKEN"] = "${{ secrets.SNYK_TOKEN }}"  # nosec

                        if "docker login" in step.get("run", ""):
                            has_docker_login = True
                        if ".pypirc" in step.get("run", ""):
                            has_pip_login = True
                            if step.get("name", "") == "Init pypi":
                                step["run"] = ruamel.yaml.scalarstring.LiteralScalarString(
                                    "\n".join(
                                        [
                                            'echo "[pypi]" > ~/.pypirc',
                                            'echo "username = ${{ secrets.PYPI_USERNAME }}" >> ~/.pypirc',
                                            'echo "password = ${{ secrets.PYPI_PASSWORD }}" >> ~/.pypirc',
                                        ]
                                    )
                                )

                        if "c2cciutils-publish" in step.get("run", ""):
                            publish_index = index
                            if not task_env.gopass:
                                step.setdefault("env", {}).update(
                                    {
                                        "GITHUB_TOKEN": task_env.token,
                                        "SNYK_TOKEN": "${{ secrets.SNYK_TOKEN }}",
                                    }
                                )

                    if not has_pip_login and not task_env.gopass and task_env.use_pypi and publish_index >= 0:
                        if task_env.use_python:
                            job["steps"] = (
                                job["steps"][:publish_index]
                                + [
                                    {
                                        "name": "Init pypi",
                                        "run": ruamel.yaml.scalarstring.LiteralScalarString(
                                            "\n".join(
                                                [
                                                    'echo "[pypi]" > ~/.pypirc',
                                                    'echo "username = ${{ secrets.PYPI_USERNAME }}" >> ~/.pypirc',
                                                    'echo "password = ${{ secrets.PYPI_PASSWORD }}" >> ~/.pypirc',
                                                ]
                                            )
                                        ),
                                    }
                                ]
                                + job["steps"][publish_index:]
                            )
                    if (
                        not has_docker_login
                        and not task_env.gopass
                        and task_env.use_docker
                        and publish_index >= 0
                    ):
                        job["steps"] = (
                            job["steps"][:publish_index]
                            + [
                                {
                                    "run": "docker login --username=${{ secrets.DOCKER_USERNAME }} --password=${{ secrets.DOCKER_PASSWORD }}"
                                }
                            ]
                            + job["steps"][publish_index:]
                        )

            publish_job = None
            for name, job in yaml["jobs"].items():
                for index, step in enumerate(job["steps"]):
                    if "c2cciutils-publish" in step.get("run", ""):
                        publish_job = name
                        break
                if publish_job is not None:
                    break

            if publish_job is not None:
                if os.path.exists(".github/run-changelog.mjs"):
                    os.remove(".github/run-changelog.mjs")

                create_release = task_env.config.enabled("changelogCreateRelease", not task_env.use_helm)
                if not create_release:
                    yaml.setdefault("permissions", {})["actions"] = "write"
                    yaml.setdefault("permissions", {})["contents"] = "write"

                    changelog_with = {
                        "script": ruamel.yaml.scalarstring.LiteralScalarString(
                            "\n".join(
                                [
                                    "if (process.env.GITHUB_REF_TYPE == 'tag') {",
                                    "    console.log('Trigger changelog');",
                                    "    await github.rest.repos.createDispatchEvent({",
                                    "        owner: 'camptocamp',",
                                    "        repo: 'helm-mutualize',",
                                    "        event_type: 'changelog',",
                                    "    });",
                                    "}",
                                ]
                            )
                        )
                    }
                    steps = yaml["jobs"][publish_job]["steps"]
                    present = False
                    for index, step in enumerate(steps):
                        if step.get("run") == "npm install @octokit/action":
                            present = True
                            del steps[index]
                            break

                    for index, step in enumerate(steps):
                        if (
                            step.get("name") in ("Run changelog", "Trigger changelog workflow")
                            or step.get("run") == "node .github/run-changelog.mjs"
                        ):
                            present = True
                            step["name"] = "Trigger changelog workflow"
                            step["uses"] = "actions/github-script@v7"
                            step["with"] = changelog_with
                            if "run" in step:
                                del step["run"]
                            break

                    if not present:
                        steps.append(
                            {
                                "name": "Trigger changelog workflow",
                                "uses": "actions/github-script@v7",
                                "with": changelog_with,
                            }
                        )
                        steps.ca.items[len(steps) - 1] = [
                            None,
                            [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                            None,
                            None,
                        ]

            if not task_env.on_stabilization_branches or yaml.is_modified():
                _canonicalize_workflow(yaml)


def _update_audit_workflow(task_env: TaskEnv) -> None:
    if task_env.has_stabilization_branches:
        if not os.path.exists(".github/workflows/audit.yaml"):
            with mra.Edit(".github/workflows/audit.yaml") as text:
                text.data = "\n".join(
                    [
                        "name: Audit",
                        "",
                        "on:",
                        "  schedule:",
                        "    - cron: '30 2 * * *'",
                        "",
                        "jobs:",
                        "  audit:",
                        "    runs-on: ubuntu-22.04",
                        "    name: Audit",
                        "    timeout-minutes: 10",
                        "",
                        "    strategy:",
                        "      fail-fast: false",
                        "      matrix:",
                        "        branch: []",
                        "",
                        "    steps:",
                        "      # Remove Python packages with wrong version",
                        "      - run: sudo apt-get remove python3-debian python3-distro-info",
                        "      - uses: actions/checkout@v4",
                        "        with:",
                        "          ref: ${{ matrix.branch }}",
                        "",
                        "      - uses: camptocamp/initialise-gopass-summon-action@v2",
                        "        with:",
                        "          ci-gpg-private-key: ${{secrets.CI_GPG_PRIVATE_KEY}}",
                        "          github-gopass-ci-token: ${{secrets.GOPASS_CI_GITHUB_TOKEN}}",
                        "",
                        "      - run: python3 -m venv ~/.venv",
                        "      - run: ~/.venv/bin/pip install --pre c2cciutils[audit]",
                        "",
                        "      - name: Check .tool-versions file existence",
                        "        id: tool-versions",
                        "        uses: andstor/file-existence-action@v2",
                        "        with:",
                        "          files: .tool-versions",
                        "      - uses: asdf-vm/actions/install@v3",
                        "        if: steps.tool-versions.outputs.files_exists == 'true'",
                        "      - run: cat /tmp/python-build.*.log",
                        "        if: failure()",
                        "      - run: python --version",
                        "",
                        "      - name: Audit",
                        "        run: ~/.venv/bin/c2cciutils-audit --branch=${{ matrix.branch }}",
                        "      - name: Audit Snyk debug",
                        "        run: ~/.venv/bin/c2cciutils-audit --branch=${{ matrix.branch }} || true",
                        "        if: failure()",
                        "        env:",
                        "          DEBUG: '*snyk*'",
                    ]
                )
    if os.path.exists(".github/workflows/audit.yaml"):
        with mra.EditYAML(".github/workflows/audit.yaml") as yaml:
            if task_env.gopass:
                gopass_init = False
                checkout_index = -1
                job_config = None
                for job in yaml["jobs"].values():
                    for index, step in enumerate(job["steps"]):
                        if step.get("uses", "").startswith("actions/checkout@"):
                            checkout_index = index
                            job_config = job
                        if step.get("uses", "").startswith("camptocamp/initialise-gopass-summon-action@"):
                            gopass_init = True

                if not gopass_init:
                    assert job_config is not None
                    job_config["steps"].insert(
                        checkout_index + 1,
                        {
                            "uses": "camptocamp/initialise-gopass-summon-action@v2",
                            "with": {
                                "ci-gpg-private-key": "${{secrets.CI_GPG_PRIVATE_KEY}}",
                                "github-gopass-ci-token": task_env.token,
                            },
                        },
                    )
                    job_config["steps"].ca.items[checkout_index] = [
                        None,
                        None,
                        [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                        None,
                    ]
                    job_config["steps"].ca.items[checkout_index + 1] = [
                        None,
                        None,
                        [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                        None,
                    ]
            else:
                gopass_index = -1
                for job in yaml["jobs"].values():
                    for index, step in enumerate(job["steps"]):
                        if step.get("uses", "").startswith("camptocamp/initialise-gopass-summon-action@"):
                            gopass_index = index
                if gopass_index >= 0:
                    for job in yaml["jobs"].values():
                        del job["steps"][gopass_index]

            for job in yaml["jobs"].values():
                checkout_step = -999
                missing_git_config = False
                audit_found = False
                dpkg_found = False
                for nb, step in enumerate(job["steps"]):
                    if step.get("uses", "").startswith("actions/checkout"):
                        step.setdefault("with", {})["token"] = task_env.token
                        checkout_step = nb
                    if nb == checkout_step + 1:
                        if not step.get("run", "").startswith("git config ") and not task_env.gopass:
                            missing_git_config = True
                    if "c2cciutils-audit" in step.get("run", ""):
                        if "DEBUG" in step.get("env", {}):
                            step["name"] = "Debug Snyk audit"
                        else:
                            step["name"] = "Snyk audit"
                            audit_found = True
                        step.setdefault("env", {})["GITHUB_TOKEN"] = task_env.token
                        if not task_env.gopass:
                            step.setdefault("env", {})["SNYK_TOKEN"] = "${{ secrets.SNYK_TOKEN }}"
                    if "c2cciutils-docker-versions-update" in step.get("run", ""):
                        step["name"] = "Update dpkg packages versions"
                        step[
                            "run"
                        ] = "~/.venv/bin/c2cciutils-docker-versions-update --branch=${{ matrix.branch }}"
                        dpkg_found = True

                        step["if"] = "steps.dpkg-versions.outputs.files_exists == 'true'"
                        step.setdefault("env", {})["GITHUB_TOKEN"] = task_env.token
                        if "SNYK_TOKEN" in step["env"]:
                            del step["env"]["SNYK_TOKEN"]

                if missing_git_config:
                    job["steps"].insert(
                        checkout_step + 1,
                        {
                            "name": "Configure git user name",
                            "run": 'git config user.name "Snyk autofix"',
                        },
                    )
                    job["steps"].insert(
                        checkout_step + 1,
                        {
                            "name": "Configure git user email",
                            "run": 'git config user.email "snyk@ci.com"',
                        },
                    )

                if not audit_found:
                    job["steps"].append(
                        {
                            "name": "Snyk audit",
                            "run": "c2cciutils-audit --branch=${{ matrix.branch }}",
                            "env": {  # type: ignore[dict-item]
                                "GITHUB_TOKEN": task_env.token,
                            },
                        }
                        if task_env.gopass
                        else {
                            "name": "Snyk audit",
                            "run": "c2cciutils-audit --branch=${{ matrix.branch }}",
                            "env": {  # type: ignore[dict-item]
                                "GITHUB_TOKEN": task_env.token,
                                "SNYK_TOKEN": "${{ secrets.SNYK_TOKEN }}",
                            },
                        }
                    )

                if not dpkg_found:
                    job["steps"].append(
                        {
                            "name": "Check ci/dpkg-versions.yaml file existence",
                            "id": "dpkg-versions",
                            "uses": "andstor/file-existence-action@v2",
                            "with": {"files": "ci/dpkg-versions.yaml"},
                        }
                    )
                    job["steps"].append(
                        {
                            "name": "Update dpkg packages versions",
                            "run": "~/.venv/bin/c2cciutils-docker-versions-update --branch=${{ matrix.branch }}",
                            "if": "steps.dpkg-versions.outputs.files_exists == 'true'",
                            "env": {  # type: ignore[dict-item]
                                "GITHUB_TOKEN": task_env.token,
                            },
                        }
                        if task_env.gopass
                        else {
                            "name": "Update dpkg packages versions",
                            "run": "~/.venv/bin/c2cciutils-docker-versions-update --branch=${{ matrix.branch }}",
                            "if": "steps.dpkg-versions.outputs.files_exists == 'true'",
                            "env": {  # type: ignore[dict-item]
                                "GITHUB_TOKEN": task_env.token,
                                "SNYK_TOKEN": "${{ secrets.SNYK_TOKEN }}",
                            },
                        }
                    )

            if not task_env.on_stabilization_branches or yaml.is_modified():
                _canonicalize_workflow(yaml)


def _update_changelog_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/changelog-config.yaml"):
        os.remove(".github/changelog-config.yaml")
    if os.path.exists("CHANGELOG.md"):
        os.remove("CHANGELOG.md")
    if not os.path.exists(".github/workflows/changelog.yaml"):
        with mra.Edit(".github/workflows/changelog.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Changelog Generator",
                    "",
                    "on:",
                    "  schedule:",
                    "    - cron: 0 0 * * 1,4",
                    "  push:",
                    "    tags:",
                    "      - '*.*.*'",
                    "",
                    "jobs:",
                    "  changelog:",
                    "    name: Changelog Generator",
                    "    runs-on: ubuntu-22.04",
                    "    timeout-minutes: 30",
                    "",
                    "    steps:",
                    "      - uses: actions/checkout@v4",
                    "        if: github.event_name == 'push' && github.ref_type == 'tag'",
                    "      - name: Create release",
                    "        run: |-",
                    r"          if [[ ${{ github.ref_name }} =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then",
                    "            gh release create ${{ github.ref_name }} --generate-notes || true",
                    "          fi",
                    "        if: github.event_name == 'push' && github.ref_type == 'tag'",
                    "        env:",
                    "          GH_TOKEN: ${{ secrets.GOPASS_CI_GITHUB_TOKEN }}",
                    "",
                    "      - name: Get Date",
                    "        id: get-date",
                    '        run: echo "date=$(/bin/date -u "+%Y%m%d%H%M%S")" >> $GITHUB_OUTPUT',
                    "      - uses: actions/cache@v3",
                    "        with:",
                    "          path: .cache",
                    "          key: automation-${{ steps.get-date.outputs.date }}",
                    "          restore-keys: |+",
                    "            automation-",
                    "",
                    "      - run: docker pull aeonphp/automation",
                    "      - name: Generate changelog",
                    "        run: >-",
                    "          docker run --env=AEON_AUTOMATION_GH_TOKEN --rm --volume=$(pwd)/.cache:/cache aeonphp/automation",
                    "          changelog:generate:all",
                    "          ${{ github.repository }}",
                    "          --github-release-update",
                    "          --cache-path=/cache",
                    "          --skip-from=dependabot-preview[bot]",
                    "          --skip-from=dependabot[bot]",
                    "          --skip-from=renovate[bot]",
                    "          -v",
                    "        env:",
                    "          AEON_AUTOMATION_GH_TOKEN: ${{ secrets.GOPASS_CI_GITHUB_TOKEN }}",
                ]
            )
    create_release = task_env.config.enabled("changelogCreateRelease", not task_env.use_helm)
    if task_env.on_stabilization_branches and not create_release:
        os.remove(".github/workflows/changelog.yaml")
        return

    with mra.EditYAML(".github/workflows/changelog.yaml") as yaml:
        yaml.setdefault("on", {})["schedule"] = [{"cron": "0 0 * * 1,4"}]
        if "push" in yaml["on"]:
            del yaml["on"]["push"]

        if create_release:
            yaml["on"]["push"] = {"tags": mra_yaml.commented_sec([["*.*.*", "\n\n"]])}
        else:
            if "workflow_dispatch" in yaml["on"]:
                del yaml["on"]["workflow_dispatch"]
            yaml["on"]["repository_dispatch"] = {"types": ["changelog"]}

        create_release_step = (
            [
                {
                    "uses": "actions/checkout@v4",
                    "if": "github.event_name == 'push' && github.ref_type == 'tag'",
                },
                {
                    "name": "Create release",
                    "run": ruamel.yaml.scalarstring.LiteralScalarString(
                        "\n".join(
                            [
                                "if [[ ${{ github.ref_name }} =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then",
                                "  gh release create ${{ github.ref_name }} --generate-notes || true",
                                "fi",
                            ]
                        )
                    ),
                    "if": "github.event_name == 'push' && github.ref_type == 'tag'",
                    "env": mra_yaml.commented_map(
                        {
                            "GH_TOKEN": [
                                task_env.token,
                                "\n\n",
                            ],
                        }
                    ),
                },
            ]
            if create_release
            else []
        )
        yaml.setdefault("jobs", {}).setdefault("changelog", {})["steps"] = [
            *create_release_step,
            {
                "name": "Get Date",
                "id": "get-date",
                "run": 'echo "date=$(/bin/date -u "+%Y%m%d%H%M%S")" >> $GITHUB_OUTPUT',
            },
            {
                "uses": "actions/cache@v3",
                "with": {
                    "path": ".cache",
                    "key": "automation-${{ steps.get-date.outputs.date }}",
                    "restore-keys": ruamel.yaml.scalarstring.LiteralScalarString("automation-\n\n"),
                },
            },
            {
                "run": "docker pull aeonphp/automation",
            },
            {
                "name": "Generate changelog",
                "run": mra_yaml.folder_scalar_string(
                    [
                        "docker run --env=AEON_AUTOMATION_GH_TOKEN --rm --volume=$(pwd)/.cache:/cache aeonphp/automation",
                        "changelog:generate:all",
                        "${{ github.repository }}",
                        "--github-release-update",
                        "--cache-path=/cache",
                        "--skip-from=dependabot-preview[bot]",
                        "--skip-from=dependabot[bot]",
                        "--skip-from=renovate[bot]",
                        "-v",
                        *task_env.config.value("changelogAdditionalArgs", []),
                    ]
                ),
                "env": {
                    "AEON_AUTOMATION_GH_TOKEN": task_env.token,
                },
            },
        ]

        for job in yaml["jobs"].values():
            for step in job["steps"]:
                if step.get("name", "") == "Create release":
                    step.setdefault("env", {})["GH_TOKEN"] = task_env.token
                if step.get("name", "") == "Generate changelog":
                    step.setdefault("env", {})["AEON_AUTOMATION_GH_TOKEN"] = task_env.token

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_clean_workflow(task_env: TaskEnv) -> None:
    if not task_env.use_docker:
        if os.path.exists(".github/workflows/clean.yaml"):
            os.remove(".github/workflows/clean.yaml")
        return
    if not os.path.exists(".github/workflows/clean.yaml"):
        with mra.Edit(".github/workflows/clean.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Clean docker hub tags",
                    "",
                    "on:",
                    "  delete:",
                    "  pull_request:",
                    "    types:",
                    "      - closed",
                    "",
                    "jobs:",
                    "  clean:",
                    "    runs-on: ubuntu-22.04",
                    "    name: Clean docker hub tags",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - uses: actions/checkout@v4",
                    "",
                    "      - uses: camptocamp/initialise-gopass-summon-action@v2",
                    "        with:",
                    "          ci-gpg-private-key: ${{secrets.CI_GPG_PRIVATE_KEY}}",
                    "          github-gopass-ci-token: ${{secrets.GOPASS_CI_GITHUB_TOKEN}}",
                    "          patterns: docker",
                    "",
                    '      - run: echo "${HOME}/.local/bin" >> ${GITHUB_PATH}',
                    "      - run: python3 -m pip install --user --requirement=ci/requirements.txt",
                    "",
                    "      - name: Clean Docker hub tags",
                    "        run: c2cciutils-clean",
                ]
            )
    with mra.EditYAML(".github/workflows/clean.yaml") as yaml:
        if task_env.gopass:
            gopass_init = False
            checkout_index = -1
            job_config = None
            for job in yaml["jobs"].values():
                for index, step in enumerate(job["steps"]):
                    if step.get("uses", "").startswith("actions/checkout@"):
                        checkout_index = index
                        job_config = job
                    if step.get("uses", "").startswith("camptocamp/initialise-gopass-summon-action@"):
                        gopass_init = True

            if not gopass_init:
                assert job_config is not None
                job_config["steps"].insert(
                    checkout_index + 1,
                    {
                        "uses": "camptocamp/initialise-gopass-summon-action@v2",
                        "with": {
                            "ci-gpg-private-key": "${{secrets.CI_GPG_PRIVATE_KEY}}",
                            "github-gopass-ci-token": task_env.token,
                        },
                    },
                )
                job_config["steps"].ca.items[checkout_index] = [
                    None,
                    None,
                    [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                    None,
                ]
                job_config["steps"].ca.items[checkout_index + 1] = [
                    None,
                    None,
                    [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                    None,
                ]
        else:
            gopass_index = -1
            for job in yaml["jobs"].values():
                for index, step in enumerate(job["steps"]):
                    if step.get("uses", "").startswith("camptocamp/initialise-gopass-summon-action@"):
                        gopass_index = index
            if gopass_index >= 0:
                for job in yaml["jobs"].values():
                    del job["steps"][gopass_index]

        for job in yaml["jobs"].values():
            for step in job["steps"]:
                if "c2cciutils-clean" in step.get("run", ""):
                    step["name"] = "Clean Docker hub tags"
                    if not task_env.gopass:
                        step.setdefault("env", {}).update(
                            {
                                "DOCKERHUB_PASSWORD": "${{ secrets.DOCKER_PASSWORD }}",
                                "DOCKERHUB_USERNAME": "${{ secrets.DOCKER_USERNAME }}",
                            }
                        )

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_delete_old_workflow_run_workflow(task_env: TaskEnv) -> None:
    if not os.path.exists(".github/workflows/delete-old-workflow-run.yaml"):
        with mra.Edit(".github/workflows/delete-old-workflow-run.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Delete old workflow runs",
                    "",
                    "on:",
                    "  schedule:",
                    "    - cron: '0 0 * * *'",
                    "",
                    "env:",
                    "  HAS_SECRETS: ${{ secrets.HAS_SECRETS }}",
                    "",
                    "jobs:",
                    "  build:",
                    "    runs-on: ubuntu-22.04",
                    "    timeout-minutes: 25",
                    "    name: Delete old workflow runs",
                    "",
                    "    steps:",
                    "      - name: Delete old workflow runs",
                    "        uses: MajorScruffy/delete-old-workflow-runs@v0.3.0",
                    "        with:",
                    "          repository: ${{ github.repository }}",
                    "          older-than-seconds: 43200000 # 500 days",
                    "        env:",
                    "          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}",
                ]
            )
    with mra.EditYAML(".github/workflows/delete-old-workflow-run.yaml") as yaml:
        for job in yaml["jobs"].values():
            for step in job["steps"]:
                if step.get("uses", "").startswith("MajorScruffy/delete-old-workflow-runs"):
                    step["name"] = "Delete old workflow runs"
                    step.setdefault("env", {})["GITHUB_TOKEN"] = task_env.token

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_dependency_auto_review_workflow(task_env: TaskEnv) -> None:
    for file_ in (
        ".github/workflows/dependabot-auto-merge.yaml",
        ".github/workflows/auto-review.yaml",
        ".github/workflows/auto-merge.yaml",
        ".github/workflows/dependency-update-review.yaml",
    ):
        if os.path.exists(file_):
            if os.path.exists(".github/workflows/dependency-auto-review.yaml"):
                os.remove(file_)
            else:
                mra.run(
                    [
                        "git",
                        "mv",
                        file_,
                        ".github/workflows/dependency-auto-review.yaml",
                    ]
                )
    if not os.path.exists(".github/workflows/dependency-auto-review.yaml"):
        with mra.Edit(".github/workflows/dependency-auto-review.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Auto reviews updates",
                    "",
                    "on:",
                    "  pull_request:",
                    "    types:",
                    "      - opened",
                    "      - reopened",
                    "",
                    "jobs:",
                    "  auto-merge:",
                    "    name: Auto reviews updates",
                    "    runs-on: ubuntu-22.04",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - uses: actions/github-script@v7",
                    "        with:",
                    "          script: |-",
                    "            github.rest.pulls.createReview({",
                    "              owner: context.repo.owner,",
                    "              repo: context.repo.repo,",
                    "              pull_number: context.payload.pull_request.number,",
                    "              event: 'APPROVE',",
                    "            })",
                    "    if: github.event.pull_request.user.login == 'renovate[bot]'",
                ]
            )
    with mra.EditYAML(".github/workflows/dependency-auto-review.yaml") as yaml:
        users = task_env.config.value("dependencyAutoReviewUsers", ["renovate[bot]"])
        yaml["on"] = {"pull_request": {"types": ["opened", "reopened"]}}
        for job in yaml["jobs"].values():
            job["if"] = " or ".join([f"github.event.pull_request.user.login == '{user}'" for user in users])
            job["steps"][0]["with"] = {
                "script": ruamel.yaml.scalarstring.LiteralScalarString(
                    "\n".join(
                        [
                            "github.rest.pulls.createReview({",
                            "  owner: context.repo.owner,",
                            "  repo: context.repo.repo,",
                            "  pull_number: context.payload.pull_request.number,",
                            "  event: 'APPROVE',",
                            "})",
                        ]
                    )
                )
            }

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_pull_request_checks_workflow(task_env: TaskEnv) -> None:
    if not os.path.exists(".github/workflows/pr-checks.yaml"):
        with mra.Edit(".github/workflows/pr-checks.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Pull request check",
                    "",
                    "on:",
                    "  pull_request:",
                    "    types:",
                    "      - opened",
                    "      - reopened",
                    "      - labeled",
                    "      - unlabeled",
                    "      - edited",
                    "      - synchronize",
                    "",
                    "jobs:",
                    "  build:",
                    "    name: Pull request check",
                    "    runs-on: ubuntu-22.04",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - run: pip install --upgrade attrs",
                    "      - uses: actions/checkout@v4",
                    "",
                    '      - run: echo "${HOME}/.local/bin" >> ${GITHUB_PATH}',
                    "      - run: python3 -m pip install --user --pre c2cciutils[pr_checks]",
                    "",
                    "      - name: Check pull request",
                    "        run: c2cciutils-pull-request-checks",
                    "        env:",
                    "          GITHUB_EVENT: ${{ toJson(github) }}",
                    "          GITHUB_TOKEN: ${{ secrets.GOPASS_CI_GITHUB_TOKEN }}",
                ]
            )
    with mra.EditYAML(".github/workflows/pr-checks.yaml") as yaml:
        if "attrs" not in yaml["jobs"]["build"]["steps"][0].get("run", ""):
            yaml["jobs"]["build"]["steps"].insert(
                0,
                {
                    "run": "pip install --upgrade attrs",
                },
            )
        else:
            yaml["jobs"]["build"]["steps"][0]["run"] = "pip install --upgrade attrs"

        for job in yaml["jobs"].values():
            job["if"] = "github.event.pull_request.user.login != 'renovate[bot]'"
            for step in job["steps"]:
                if step.get("run", "") == "c2cciutils-pull-request-checks":
                    step["name"] = "Check pull request"
                    step.setdefault("env", {}).update(
                        {
                            "GITHUB_EVENT": "${{ toJson(github) }}",
                            "GITHUB_TOKEN": task_env.token,
                        }
                    )
        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_backport_workflow(task_env: TaskEnv) -> None:
    if not task_env.has_stabilization_branches:
        if os.path.exists(".github/workflows/backport.yaml"):
            os.remove(".github/workflows/backport.yaml")
        return
    if not os.path.exists(".github/workflows/backport.yaml"):
        with mra.Edit(".github/workflows/backport.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Backport",
                    "",
                    "on:",
                    "  pull_request:",
                    "    types:",
                    "      - closed",
                    "      - labeled",
                    "",
                    "env:",
                    "  HAS_SECRETS: ${{ secrets.HAS_SECRETS }}",
                    "",
                    "jobs:",
                    "  backport:",
                    "    runs-on: ubuntu-22.04",
                    "    name: Backport",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - uses: camptocamp/backport-action@master",
                    "        with:",
                    "          token: ${{ secrets.GOPASS_CI_GITHUB_TOKEN }}",
                    "        if: env.HAS_SECRETS == 'HAS_SECRETS'",
                ]
            )
    with mra.EditYAML(".github/workflows/backport.yaml") as yaml:
        for job in yaml["jobs"].values():
            for step in job["steps"]:
                if step.get("uses", "") == "camptocamp/backport-action@master":
                    step.setdefault("with", {})["token"] = task_env.token

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_rebuild_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/workflows/rebuild.yaml"):
        with mra.EditYAML(".github/workflows/rebuild.yaml") as yaml:
            for job in yaml["jobs"].values():
                if "master" in job.get("strategy", {}).get("matrix", {}).get("branch", []):
                    job["strategy"]["matrix"]["branch"].remove("master")

                for step in job["steps"]:
                    if step.get("run", "") == "c2cciutils-checks":
                        if not task_env.gopass:
                            env = step.setdefault("env", {})
                            env["SNYK_TOKEN"] = "${{ secrets.SNYK_TOKEN }}"  # nosec

                    if "c2cciutils-publish" in step.get("run", ""):
                        if not task_env.gopass:
                            step.setdefault("env", {}).update(
                                {"GITHUB_TOKEN": task_env.token, "SNYK_TOKEN": "${{ secrets.SNYK_TOKEN }}"}
                            )

            if not task_env.on_stabilization_branches or yaml.is_modified():
                _canonicalize_workflow(yaml)


def _update_pyproject_toml(task_env: TaskEnv) -> None:
    """
    Add or update the Poetry extensions to the pyproject.toml file.
    """

    poetry_version = version.parse("0.0.0")
    for requirements_file_name in ("requirements.txt", "ci/requirements.txt"):
        if os.path.exists(requirements_file_name):
            with mra.Edit(requirements_file_name) as requirements_txt:
                for line in requirements_txt.data.splitlines():
                    if line.startswith("poetry=="):
                        poetry_version = version.parse(line.split("==")[1])
                        break

    if poetry_version >= version.parse("1.3.0"):
        for pyproject_filename in ("pyproject.toml", "app/pyproject.toml", "api/pyproject.toml"):
            if os.path.exists(pyproject_filename):
                with mra.EditTOML(pyproject_filename) as pyproject:
                    if "requires" in pyproject.get("build-system", {}) and "python" in pyproject.get(
                        "tool", {}
                    ).get("poetry", {}).get("dependencies", {}):
                        for plugin in (
                            "poetry-dynamic-versioning",
                            "poetry-plugin-tweak-dependencies-version",
                            "poetry-plugin-drop-python-upper-constraint",
                        ):
                            if plugin not in pyproject["build-system"]["requires"]:
                                pyproject.data["build-system"]["requires"].append(plugin)
                        for requirements_file_name in ("requirements.txt", "ci/requirements.txt"):
                            if os.path.exists(requirements_file_name):
                                with mra.Edit(requirements_file_name) as requirements_txt:
                                    if "poetry" in requirements_txt.data:
                                        for plugin, plugin_version in (
                                            ("poetry-dynamic-versioning", "1.1.0"),
                                            ("poetry-plugin-export", "1.5.0"),
                                            ("poetry-plugin-tweak-dependencies-version", "1.5.1"),
                                            ("poetry-plugin-drop-python-upper-constraint", "0.1.0"),
                                        ):
                                            if (
                                                f"{plugin}==" not in requirements_txt.data
                                                and f"{plugin}[" not in requirements_txt.data
                                            ):
                                                requirements_txt.data += f"{plugin}=={plugin_version}\n"

                        poetry_dynamic_versioning = pyproject.setdefault("tool", {}).setdefault(
                            "poetry-dynamic-versioning", {}
                        )
                        poetry_dynamic_versioning.setdefault("enable", True)
                        poetry_dynamic_versioning.setdefault("vcs", "git")
                        poetry_dynamic_versioning.setdefault("pattern", "^(?P<base>\\d+(\\.\\d+)*)")
                        if "style" in poetry_dynamic_versioning:
                            del poetry_dynamic_versioning["style"]
                        poetry_dynamic_versioning["format-jinja"] = tomlkit.items.String.from_raw(
                            "\n".join(
                                [
                                    "",
                                    '{%- if env.get("VERSION_TYPE") == "version_branch" -%}',
                                    '{{serialize_pep440(bump_version(base, 1 if env.get("IS_MASTER") == "TRUE" else 2), dev=distance)}}',
                                    "{%- elif distance == 0 -%}",
                                    "{{serialize_pep440(base)}}",
                                    "{%- else -%}",
                                    "{{serialize_pep440(bump_version(base), dev=distance)}}",
                                    "{%- endif -%}",
                                    "",
                                ]
                            ),
                            tomlkit.items.StringType.MLB,
                        )
                        poetry_plugin_tweak_dependencies_version = pyproject.setdefault(
                            "tool", {}
                        ).setdefault("poetry-plugin-tweak-dependencies-version", {})
                        poetry_plugin_tweak_dependencies_version.setdefault("default", "present")


def _update_renovate_config(task_env: TaskEnv) -> None:
    if task_env.c2cciutils_version >= version.parse("1.6.0"):
        if not os.path.exists(".github/renovate.json5"):
            with mra.Edit(".github/renovate.json5") as renovate_config:
                renovate_config.data = "{}"

    with mra.EditRenovateConfigV2() as renovate_config:
        renovate_config.setdefault("extends", ["config:base"])

        if renovate_config.get("extends", []) == ["config:base"]:
            renovate_config["extends"] = [
                ":dependencyDashboard",
                "group:monorepos",
                "group:recommended",
                "replacements:all",
                "workarounds:all",
            ]

        renovate_config.setdefault("timezone", "Europe/Zurich")
        renovate_config["schedule"] = "after 5pm on the first day of the month"
        renovate_config.setdefault("labels", ["dependencies"])
        renovate_config.setdefault("separateMajorMinor", True)
        renovate_config.setdefault("separateMinorPatch", True)
        renovate_config.setdefault("prHourlyLimit", 0)
        renovate_config.setdefault("prConcurrentLimit", 0)
        renovate_config.setdefault(
            "lockFileMaintenance",
            {
                "enabled": True,
                "automerge": True,
                "schedule": "after 5pm on the first day of the month",
            },
        )

        # Fix escapes
        for regex_manager in renovate_config.data.get("regexManagers", []):
            file_match = regex_manager["fileMatch"]
            match_strings = regex_manager["matchStrings"]
            if isinstance(file_match, mra.JSON5RowAttribute):
                if re.search(
                    r"\\*.pre-commit-config\\*.yaml",
                    json5.dumps(file_match.value),
                ):
                    file_match.value = [f'^{re.escape(".pre-commit-config.yaml")}$']
                if re.search(
                    r"ci/dpkg-versions\\*.yaml",
                    json5.dumps(file_match.value),
                ):
                    file_match.value = [f'^{re.escape("ci/dpkg-versions.yaml")}$']
                if re.search(
                    r"ci/config\\*.yaml",
                    json5.dumps(file_match.value),
                ):
                    file_match.value = [f'^{re.escape("ci/config.yaml")}$']
            if isinstance(match_strings, mra.JSON5List) and re.search(
                r"\.\*https://raw\\*.githubusercontent\\*.com/(\?<depName>[^\\*s]+)/(\?<currentValue>[0-9\\*.]\+)/\.\*",
                json5.dumps(regex_manager["matchStrings"][0].value),
            ):
                regex_manager["matchStrings"][
                    0
                ].value = (
                    r".*https://raw\.githubusercontent\.com/(?<depName>[^\s]+)/(?<currentValue>[0-9\.]+)/.*"
                )

        renovate_config["schedule"] = "after 5pm on the first day of the month"
        if os.path.exists(".pre-commit-config.yaml"):
            preCommit = mra.JSON5RowDict()
            preCommit.comment = ["Do updates on pre-commit config"]
            preCommit.value = {"enabled": True}

            renovate_config.add_regex_manager(
                {
                    "fileMatch": [f'^{re.escape(".pre-commit-config.yaml")}$'],
                    "matchStrings": [
                        " +- '?(?<depName>[^' @=]+)(@|==)(?<currentValue>[^' @=]+)'? # (?<datasource>.+)"
                    ],
                },
                ["Do updates on pre-commit additional dependencies"],
            )
        # No more do update on packages update (trigger a rebuild)
        renovate_config.remove_regex_manager(
            {
                "fileMatch": [f'^{re.escape("ci/dpkg-versions.yaml")}$'],
                "matchStrings": [r" *(?<depName>[^'\s]+): '?(?<currentValue>[^'\s/]*[0-9][^'\s/]*)'?"],
                "datasourceTemplate": "repology",
                "versioningTemplate": "loose",
            },
            ["Do update on packages update (trigger a rebuild)"],
        )
        # Do update on the schema present in the ci/config.yaml
        renovate_config.add_regex_manager(
            {
                "fileMatch": [f'^{re.escape("ci/config.yaml")}$'],
                "matchStrings": [
                    r".*https://raw\.githubusercontent\.com/(?<depName>[^\s]+)/(?<currentValue>[0-9\.]+)/.*",
                ],
                "datasourceTemplate": "github-tags",
            },
            ["Do update on the schema present in the ci/config.yaml"],
        )
        # Support the 4 parts of shellcheck-py version
        renovate_config.add_package_rule(
            {
                "matchPackageNames": ["shellcheck-py/shellcheck-py"],
                "versioning": "regex:^v(?<major>\\d+)\\.(?<minor>\\d+)\\.(?<patch>\\d+)\\.(?<build>\\d+)$",
            },
            ["Support the 4 parts of shellcheck-py version with a v prefix"],
        )
        renovate_config.add_package_rule(
            {
                "matchDepTypes": ["devDependencies"],
                "automerge": True,
            },
            ["Auto merge the dev dependency update"],
        )
        renovate_config.add_package_rule(
            {
                "matchUpdateTypes": ["patch"],
                "groupName": "all patch versions",
                "automerge": True,
            },
            ["Group and auto merge the patch updates"],
            ["matchUpdateTypes", "groupName"],
        )
        renovate_config.add_package_rule(
            {
                "matchUpdateTypes": ["minor"],
                "groupName": "all minor versions",
                "automerge": True,
            },
            ["Group and auto merge the minor updates"],
            ["matchUpdateTypes", "groupName"],
        )
        if task_env.has_stabilization_branches:
            renovate_config.add_package_rule(
                {
                    "matchBaseBranches": task_env.config.value(
                        "matchStabilizationBranches", [r"/^[0-9]+\.[0-9]+$/"]
                    ),
                    "matchUpdateTypes": [
                        "major",
                        "minor",
                        "pin",
                        "digest",
                        "lockFileMaintenance",
                        "rollback",
                        "bump",
                    ],
                    "enabled": False,
                },
                ["Accept only the patch on stabilization branches"],
                ["matchUpdateTypes"],
            )

        if task_env.use_python:
            renovate_config.add_package_rule(
                {
                    "matchPackageNames": ["poetry", "pip"],
                    "matchPackagePrefixes": ["poetry-"],
                    "groupName": "Poetry",
                    "automerge": True,
                    "separateMajorMinor": False,
                    "separateMinorPatch": False,
                },
                ["Group Poetry packages"],
            )
        if task_env.use_docker and task_env.has_stabilization_branches:
            # No more update dpkg versions every day
            renovate_config.remove_package_rule(
                {
                    "groupName": "dpkg",
                },
                ["Update dpkg versions at any time"],
            )

        renovate_config.add_package_rule(
            {"matchDatasources": ["github-actions", "pre-commit"], "automerge": True},
            ["Auto merge the GitHub action and pre-commit updates"],
        )


def _update_config(task_env: TaskEnv) -> None:
    if task_env.has_config and task_env.c2cciutils_version >= version.parse("1.6.0"):
        with mra.EditYAML("ci/config.yaml") as config:
            if "checks" in config:
                del config["checks"]
            to_delete = len(config.keys()) == 0
        if to_delete:
            os.remove("ci/config.yaml")

    if task_env.use_docker:
        if not os.path.exists("ci/dpkg-versions.yaml"):
            with open("ci/dpkg-versions.yaml", "w", encoding="utf-8") as dpkg_versions:
                dpkg_versions.write("{}")
            with mra.EditYAML("ci/dpkg-versions.yaml") as dpkg_versions:
                c2cciutils_config = c2cciutils.get_config()
                for image in c2cciutils_config.get("publish", {}).get("docker", {}).get("images", []):
                    for tag in image.get("tags", ["{version}"]):
                        try:
                            image_name = f"{image['name']}:{tag.format(version='master')}"
                            mra.run(["docker", "pull", image_name])
                            success, versions = c2cciutils.lib.docker.get_dpkg_packages_versions(image_name)
                            if success:
                                dpkg_versions[f"{image['name']}:{tag.format(version='latest')}"] = {
                                    k: str(v) for k, v in versions.items()
                                }
                        except SystemExit:
                            print(f"Error while getting dpkg versions for {image['name']}:{tag}")
                        except Exception as e:
                            print(f"Error while getting dpkg versions for {image['name']}:{tag}: {e}")


def _update_pre_commit_config(task_env: TaskEnv) -> None:
    del task_env

    if os.path.exists(".pre-commit-config.yaml"):
        with mra.EditPreCommitConfig() as pre_commit_config:
            pre_commit_config.add_repo("https://github.com/sbrunner/jsonschema-validator")
            pre_commit_config.add_hook(
                "https://github.com/sbrunner/jsonschema-validator",
                {
                    "id": "jsonschema-validator",
                    "files": pre_commit_config.create_files_regex(["ci/config\\.yaml"]),
                },
                True,
            )

            # Do a spell check on the found schemas
            schemas = []
            for files_ in ("*.schema.json", "schema.json", "schema-*.json"):
                schemas += [
                    f
                    for f in mra.run(["git", "ls-files", files_], stdout=subprocess.PIPE).stdout.split("\n")
                    if f
                ]
                # Get all the schemas files
                schemas += [
                    f
                    for f in mra.run(
                        ["git", "ls-files", f"**/{files_}"], stdout=subprocess.PIPE
                    ).stdout.split("\n")
                    if f
                ]

            if schemas:
                pre_commit_config.add_repo("https://github.com/mheap/json-schema-spell-checker", "master")
                pre_commit_config.add_hook(
                    "https://github.com/mheap/json-schema-spell-checker",
                    {
                        "id": "json-schema-spell-checker",
                        "files": pre_commit_config.create_files_regex([re.escape(f) for f in schemas]),
                        "args": [
                            "--fields=description,title",
                            "--spelling=.github/spell-ignore-words.txt",
                            "--ignore-numbers",
                            "--ignore-acronyms",
                            "--en-us",
                        ],
                    },
                )

            for repo in pre_commit_config.data["repos"]:
                # Fucking branch renaming
                if (
                    repo.get("repo", "") == "https://github.com/mheap/json-schema-spell-checker"
                    and repo["rev"] == "master"
                ):
                    repo["rev"] = "main"


def _get_env() -> TaskEnv:
    config = Config()

    use_helm = config.enabled(
        "helm", os.path.exists("Chart.yaml") or os.path.exists("test/helmchart/Chart.yaml")
    )

    gopass = config.enabled(
        "gopass",
        "no-gopass" not in config.repo.get("types", [])
        and (config.repo["name"].startswith("camptocamp/") or config.repo["name"].startswith("mapfish/")),
    )
    # Get the string we used in the workflow to get the GitHub token to be used
    token = config.value(
        "github_token_secret", "${{ secrets.GOPASS_CI_GITHUB_TOKEN }}" if gopass else "${{ secrets.TOKEN }}"
    )

    # This is to implement a workaround of this issue: https://sourceforge.net/p/ruamel-yaml/tickets/480/
    has_config = False
    if os.path.exists("ci/config.yaml"):
        with open("ci/config.yaml", encoding="utf-8") as f:
            has_config = py_yaml.load(f.read(), Loader=py_yaml.SafeLoader)

    # Get the version of c2cciutils
    c2cciutils_version = version.parse("1.6.0")
    if os.path.exists("ci/requirements.txt"):
        with mra.Edit("ci/requirements.txt") as requirements_txt:
            requirements = [
                r
                for r in requirements_txt.data.split("\n")
                if r.startswith("c2cciutils==") or r.startswith("c2cciutils[")
            ]
            if len(requirements) == 1:
                c2cciutils_version_string = requirements[0].split("==")[1]
                if c2cciutils_version_string.endswith(".*"):
                    c2cciutils_version_string = c2cciutils_version_string[:-2]
                c2cciutils_version = version.parse(c2cciutils_version_string)
    c2cciutils_version_config = config.value("c2cciutils_version")
    if c2cciutils_version_config:
        c2cciutils_version = version.parse(c2cciutils_version_config)

    use_python = False
    for pyproject_filename in ("pyproject.toml", "app/pyproject.toml", "api/pyproject.toml"):
        if os.path.exists(pyproject_filename):
            with mra.EditTOML(pyproject_filename) as pyproject:
                use_python = "project" in pyproject or "build-system" in pyproject
    use_python = config.enabled("python", use_python)

    use_pypi = config.enabled("pypi", use_python and "no-pypi" not in config.repo.get("type", []))
    use_docker = config.enabled(
        "docker",
        (os.path.exists("Dockerfile") or os.path.exists("app/Dockerfile") or os.path.exists("api/Dockerfile"))
        and "no-docker" not in config.repo.get("type", []),
    )

    stabilization_branches = mra.get_stabilization_branches(config.repo)
    master_branch = mra.get_default_branch()
    if master_branch in stabilization_branches:
        stabilization_branches.remove(master_branch)

    return TaskEnv(
        c2cciutils_version,
        use_python,
        use_pypi,
        use_docker,
        use_helm,
        has_config,
        config.arguments.on_stabilization_branches or len(stabilization_branches) > 0,
        config.arguments.on_stabilization_branches and len(stabilization_branches) > 0,
        gopass,
        token,
        config,
    )


def _do() -> None:
    task_env = _get_env()
    print(f"Task environment: {task_env}")

    for name, task in (
        ("create-labels", _create_labels),
        ("set-schema-config", _set_schema_config),
        ("upgrade-ubuntu", _upgrade_ubuntu),
        ("update-changelog-workflow", _update_changelog_workflow),
        ("update-clean-workflow", _update_clean_workflow),
        ("update-dependency-auto-review-workflow", _update_dependency_auto_review_workflow),
        ("update-pull-request-checks-workflow", _update_pull_request_checks_workflow),
        ("update-backport-workflow", _update_backport_workflow),
        ("update-main-workflow", _update_main_workflow),
    ):
        if task_env.config.enabled(name, True):
            task(task_env)
    if task_env.on_stabilization_branches:
        for file_ in (".github/workflows/delete-old-workflow-run.yaml", ".github/renovate.json5"):
            if os.path.exists(file_):
                os.remove(file_)
        for file_ in glob.glob(".github/workflows/audit*.yaml"):
            os.remove(file_)
        for file_ in glob.glob(".github/workflows/rebuild*.yaml"):
            os.remove(file_)

        if task_env.c2cciutils_version.major == 1 and task_env.c2cciutils_version.minor <= 3:
            if os.path.exists("ci/config.yaml"):
                with mra.EditYAML("ci/config.yaml") as config:
                    config.setdefault("checks", {})["required_workflows"] = False
    else:
        for name, task in (
            ("update-audit-workflow", _update_audit_workflow),
            ("update-delete-old-workflow-run-workflow", _update_delete_old_workflow_run_workflow),
            ("update-rebuild-workflow", _update_rebuild_workflow),
            ("update-pyproject-toml", _update_pyproject_toml),
            ("update-renovate-config", _update_renovate_config),
            ("update-config", _update_config),
            ("update-pre-commit-config", _update_pre_commit_config),
        ):
            if task_env.config.enabled(name, True):
                task(task_env)


if __name__ == "__main__":
    mra.main(
        _do,
        # pull_request_on_stabilization_branches
        # pull_request_title
        # pull_request_body
        # branch
        # pull_request_branch_prefix
        config={
            "branch": "c2cciutils-upgrade",
            "pull_request_branch_prefix": "c2cciutils-upgrade-",
            "pull_request_title": "CI updates",
            "pull_request_body": "This is done by the automated script named " + os.path.basename(__file__),
        },
        description="Update the repository for c2cciutils version 1.6, the will also fix the errors he found",
    )
