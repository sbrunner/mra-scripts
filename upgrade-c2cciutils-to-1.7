#!/usr/bin/env python3

import glob
import os
import re
import subprocess
from typing import Any, AnyStr, NamedTuple, Optional, Union

import c2cciutils.lib.docker
import json5
import multi_repo_automation as mra
import multi_repo_automation.commented_yaml as mra_yaml
import ruamel.yaml.comments
import ruamel.yaml.scalarstring
import tomlkit.items
import yaml as py_yaml
from packaging import version

# if os.path.exists(".github/renovate.json5"):
# if mra.run(["grep", "text", ".github/renovate.json5"], exit_on_error=False).returncode != 0: # not found
# if mra.git_grep(r"\<text\>"]): # found
# if mra.run(["git", "ls-files", "**/*.txt"], stdout=subprocess.PIPE).stdout.strip() != b"": # found
# mra.edit("file")
# input()


class Config:
    _values: dict[str, Any] = {}
    _enabled: list[str] = []
    _disabled: list[str] = []

    def __init__(self) -> None:
        self.repo = mra.get_repo_config()
        self.arguments = mra.get_arguments()

        if os.path.exists(".github/ci-upgrade.yaml"):
            with open(".github/ci-upgrade.yaml", encoding="utf-8") as f:
                upgrade_config = py_yaml.load(f.read(), Loader=py_yaml.SafeLoader)
                self._values = upgrade_config.get("values", {})
                self._enabled = upgrade_config.get("enabled", [])
                self._disabled = upgrade_config.get("disabled", [])

    def value(self, name: str, default: Any = None) -> Any:
        return self._values.get(name, default)

    def enabled(self, name: str, default: bool) -> bool:
        if name in self._enabled:
            return True
        if name in self._disabled:
            return False
        return default


class TaskEnv(NamedTuple):
    c2cciutils_version: version.Version
    set_c2cciutils_version: bool
    use_python: bool
    use_pypi: bool
    use_docker: bool
    use_helm: bool
    has_config: bool
    has_stabilization_branches: bool
    on_stabilization_branches: bool
    gopass: bool
    token: str
    config: Config


def _order_keys(
    data: dict[str, Any], first_keys: list[str], last_keys: Optional[list[str]] = None
) -> ruamel.yaml.comments.CommentedMap:
    if last_keys is None:
        last_keys = []

    # use order: <first_keys>, <other>, <last_keys>
    new_data = []
    for key in first_keys:
        if key in data:
            new_data.append((key, data[key]))

    new_data += [e for e in data.items() if e[0] not in [*first_keys, *last_keys]]

    for key in last_keys:
        if key in data:
            new_data.append((key, data[key]))

    return ruamel.yaml.comments.CommentedMap(new_data)


def _order_sub_keys(
    data: Union[dict[str, dict[str, Any]], list[dict[str, AnyStr]]],
    first_keys: list[str],
    last_keys: Optional[list[str]] = None,
) -> None:
    items = data.items() if isinstance(data, dict) else enumerate(data)
    for key, value in items:
        # copy the last comment
        comment = None
        if hasattr(value, "ca"):
            last_value = list(value.values())[-1]
            if isinstance(last_value, dict) and hasattr(last_value, "ca"):
                last_last_key = list(last_value.keys())[-1]
                comment = last_value.ca.items.get(last_last_key)
                if comment is not None:
                    del last_value.ca.items[last_last_key]
            else:
                comment = value.ca.items.get(list(value.keys())[-1])
        data[key] = _order_keys(value, first_keys, last_keys)
        if comment is not None:
            last_key = list(data[key].keys())[-1]
            if isinstance(data[key][last_key], ruamel.yaml.comments.CommentedMap):
                last_last_key = list(data[key][last_key].keys())[-1]
                data[key][last_key].ca.items[last_last_key] = comment
            else:
                data[key].ca.items[last_key] = comment


def _canonicalize_workflow(workflow: mra.EditYAML) -> None:
    workflow.data = _order_keys(workflow.data, ["name", "on", "permissions", "env"], ["jobs"])

    # Add space after simple key
    for key in ["name"]:
        workflow.data.ca.items[key] = [
            None,
            None,
            ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
            None,
        ]

    # add space after complex keys
    for key in ["on", "permissions", "env", "jobs"]:
        workflow.data.ca.items[key] = [
            None,
            [ruamel.yaml.CommentToken("\n", ruamel.yaml.error.CommentMark(0), None)],
            None,
            None,
        ]

    for name, job in workflow["jobs"].items():
        job = _order_keys(
            job,
            ["name", "runs-on", "timeout-minutes", "if", "concurrency", "needs"],
            ["strategy", "env", "steps"],
        )
        workflow["jobs"][name] = job

        for key in reversed(["name", "runs-on", "timeout-minutes", "if", "concurrency", "needs"]):
            if key in job:
                job.ca.items[key] = [
                    None,
                    None,
                    ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
                    None,
                ]
                break

        for key in reversed(["strategy", "env"]):
            if key in job:
                job.ca.items[key] = [
                    None,
                    None,
                    ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
                    None,
                ]

        for job in workflow["jobs"].values():
            if "steps" in job:
                _order_sub_keys(job["steps"], ["name"], ["uses", "with", "run", "env", "if"])


def _create_labels(task_env: TaskEnv) -> None:
    mra.gh(
        "label",
        "create",
        "--force",
        "dependencies",
        "--color=0075ca",
        "--description=Update the dependencies",
    )
    if task_env.config.enabled("pullRequestWelcome", False):
        mra.gh(
            "label",
            "create",
            "--force",
            "pull request welcome",
            "--color=6622BB",
            "--description=A pull request is welcome to fix this issue",
        )


RE_JSON_SCHEMA_SOURCE = re.compile(
    re.escape("# yaml-language-server: $schema=https://raw.githubusercontent.com/camptocamp/c2cciutils/")
    + r"([0-9.]+)"
    + re.escape("/c2cciutils/schema.json")
)


def _set_schema_config(task_env: TaskEnv) -> None:
    if os.path.exists("ci/config.yaml") and task_env.set_c2cciutils_version:
        with mra.Edit("ci/config.yaml") as ci_config:
            data = ci_config.data.split("\n")
            # Don't do the replacement from x.y.z to x.y
            match = RE_JSON_SCHEMA_SOURCE.match(data[0])
            if match and match.group(1).startswith(f"{task_env.c2cciutils_version}."):
                return

            if ci_config.data.startswith(
                "# yaml-language-server: $schema=https://raw.githubusercontent.com/camptocamp/c2cciutils"
            ):
                data = data[1:]

            while data and not data[0].strip():
                data = data[1:]

            data = [
                "# yaml-language-server: $schema=https://raw.githubusercontent.com/camptocamp/"
                f"c2cciutils/{task_env.c2cciutils_version}/c2cciutils/schema.json",
                "",
                *data,
            ]

            ci_config.data = "\n".join(data)


def _upgrade_ubuntu(task_env: TaskEnv) -> None:
    del task_env

    for workflow_file in mra.run(
        ["git", "ls-files", ".github/workflows/*.yaml"], stdout=subprocess.PIPE
    ).stdout.split("\n"):
        if workflow_file:
            try:
                with mra.EditYAML(workflow_file) as yaml:
                    for job in yaml.get("jobs", {}).values():
                        if job.get("runs-on", "").startswith("ubuntu-"):
                            job["runs-on"] = "ubuntu-22.04"
            except Exception as e:
                print(f"Error in {workflow_file}: {e}")


def _update_main_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/workflows/codeql.yaml"):
        os.remove(".github/workflows/codeql.yaml")
    if not os.path.exists(".github/workflows/main.yaml") and os.path.exists(".github/workflows/ci.yaml"):
        os.rename(".github/workflows/ci.yaml", ".github/workflows/main.yaml")
    if os.path.exists(".github/workflows/main.yaml"):
        with mra.EditYAML(".github/workflows/main.yaml") as yaml:
            if not task_env.on_stabilization_branches:
                env = yaml.setdefault("env", {})
                if "HAS_SECRETS" not in env:
                    env["HAS_SECRETS"] = "${{ secrets.HAS_SECRETS }}"

                    if hasattr(env, "ca"):
                        env.ca.items.clear()
                        env.ca.items["HAS_SECRETS"] = [
                            None,
                            None,
                            ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None),
                            None,
                        ]

            for job in yaml["jobs"].values():
                pre_commit_index = -1
                has_pre_commit_artifacts = False
                publish_index = -1
                has_publish_artifacts = False
                for index, step in enumerate(job["steps"]):
                    if step.get("run", "").startswith("pre-commit run"):
                        pre_commit_index = index
                    if step.get("run", "").startswith("c2cciutils-publish"):
                        publish_index = index
                    if (
                        step.get("uses", "").startswith("actions/upload-artifact@")
                        and step.get("with", {}).get("name", "") == "Apply pre-commit fix.patch"
                    ):
                        has_pre_commit_artifacts = True
                    if (
                        step.get("uses", "").startswith("actions/upload-artifact@")
                        and step.get("with", {}).get("name", "") == "Update dpkg versions list.patch"
                    ):
                        has_publish_artifacts = True

                index_add = 0
                for index, filename, has_artifact, artifact_name in (
                    (pre_commit_index, "pre-commit", has_pre_commit_artifacts, "Apply pre-commit fix"),
                    (publish_index, "dpkg-versions", has_publish_artifacts, "Update dpkg versions list"),
                ):
                    if index >= 0:
                        if not task_env.on_stabilization_branches:
                            if (
                                job["steps"][index + index_add].get("env", {}).get("SKIP", "").strip(",")
                                == "poetry-lock"
                            ):
                                del job["steps"][index + index_add]["env"]["SKIP"]
                                if not job["steps"][index + index_add]["env"]:
                                    del job["steps"][index + index_add]["env"]
                        if len(job["steps"]) > index + index_add + 1 and job["steps"][
                            index + index_add + 1
                        ].get("run", "").startswith("git diff"):
                            job["steps"][index + index_add + 1][
                                "run"
                            ] = f"git diff --exit-code --patch > /tmp/{filename}.patch || true"
                            job["steps"][index + index_add + 1]["if"] = "failure()"
                        else:
                            job["steps"].insert(
                                index + index_add + 1,
                                {
                                    "run": f"git diff --exit-code --patch > /tmp/{filename}.patch || true",
                                    "if": "failure()",
                                },
                            )
                            index_add += 1
                        if not has_artifact and index >= 0:
                            job["steps"].insert(
                                index + index_add + 1,
                                {
                                    "uses": "actions/upload-artifact@v4",
                                    "with": {
                                        "name": f"{artifact_name}.patch",
                                        "path": f"/tmp/{filename}.patch",
                                        "retention-days": 1,
                                    },
                                    "if": "failure()",
                                },
                            )
                            index_add += 1

                has_pip_login = False
                has_docker_login = False
                publish_index = -1

                for index, step in enumerate(job["steps"]):
                    if not task_env.on_stabilization_branches:
                        if task_env.c2cciutils_version >= version.parse("1.6.0"):
                            if step.get("run", "") == "c2cciutils-checks":
                                step["name"] = "Print environment information"
                                step["run"] = "c2cciutils-env"
                                value = None
                                if "env" in step:
                                    if step["env"].ca.items:
                                        value = list(step["env"].ca.items.values())[-1][2].value
                                    del step["env"]
                                step["env"] = {"GITHUB_EVENT": "${{ toJson(github) }}"}
                                job["steps"].ca.items[index] = [
                                    None,
                                    None,
                                    [
                                        ruamel.yaml.CommentToken(
                                            value or "\n\n", ruamel.yaml.error.CommentMark(0), None
                                        )
                                    ],
                                    None,
                                ]
                        else:
                            if step.get("run", "") == "c2cciutils-checks":
                                if not task_env.gopass:
                                    env = step.setdefault("env", {})
                                    env["SNYK_TOKEN"] = "${{ secrets.SNYK_TOKEN }}"  # nosec

                    if "docker login" in step.get("run", ""):
                        has_docker_login = True
                    if ".pypirc" in step.get("run", ""):
                        has_pip_login = True
                        if not task_env.on_stabilization_branches:
                            step["name"] = "Init pypi"
                            step["run"] = ruamel.yaml.scalarstring.LiteralScalarString(
                                "\n".join(
                                    [
                                        'echo "[pypi]" > ~/.pypirc',
                                        'echo "username = ${{ secrets.PYPI_USERNAME }}" >> ~/.pypirc',
                                        'echo "password = ${{ secrets.PYPI_PASSWORD }}" >> ~/.pypirc',
                                    ]
                                )
                            )

                    if "c2cciutils-publish" in step.get("run", ""):
                        publish_index = index
                        if not task_env.gopass:
                            step.setdefault("env", {}).update(
                                {
                                    "GITHUB_TOKEN": task_env.token,
                                    "SNYK_TOKEN": "${{ secrets.SNYK_TOKEN }}",
                                }
                            )
                        elif "env" in step:
                            if "GITHUB_TOKEN" in step["env"]:
                                del step["env"]["GITHUB_TOKEN"]
                            if "SNYK_TOKEN" in step["env"]:
                                del step["env"]["SNYK_TOKEN"]
                            if not step["env"]:
                                del step["env"]

                print(f"Update {job.get('name', '--no-name--')}")
                print(f"  has_pip_login: {has_pip_login}")
                print(f"  has_docker_login: {has_docker_login}")
                print(f"  publish_index: {publish_index}")
                print(f"  gopass: {task_env.gopass}")
                print(f"  use_pypi: {task_env.use_pypi}")
                print(f"  use_docker: {task_env.use_docker}")
                print(f"  use_python: {task_env.use_python}")
                if not has_pip_login and not task_env.gopass and task_env.use_pypi and publish_index >= 0:
                    if task_env.use_python:
                        job["steps"] = (
                            job["steps"][:publish_index]
                            + [
                                {
                                    "name": "Init pypi",
                                    "run": ruamel.yaml.scalarstring.LiteralScalarString(
                                        "\n".join(
                                            [
                                                'echo "[pypi]" > ~/.pypirc',
                                                'echo "username = ${{ secrets.PYPI_USERNAME }}" >> ~/.pypirc',
                                                'echo "password = ${{ secrets.PYPI_PASSWORD }}" >> ~/.pypirc',
                                            ]
                                        )
                                    ),
                                }
                            ]
                            + job["steps"][publish_index:]
                        )
                if (
                    not has_docker_login
                    and not task_env.gopass
                    and task_env.use_docker
                    and publish_index >= 0
                ):
                    job["steps"] = (
                        job["steps"][:publish_index]
                        + [
                            {
                                "run": "docker login --username=${{ secrets.DOCKER_USERNAME }} --password=${{ secrets.DOCKER_PASSWORD }}"
                            }
                        ]
                        + job["steps"][publish_index:]
                    )

            if not task_env.on_stabilization_branches or yaml.is_modified():
                _canonicalize_workflow(yaml)


def _update_audit_workflow(task_env: TaskEnv) -> None:
    pass
    # if os.path.exists(".github/workflows/audit.yaml"):
    #    os.remove(".github/workflows/audit.yaml")


def _update_changelog_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/changelog-config.yaml"):
        os.remove(".github/changelog-config.yaml")
    if os.path.exists(".github/workflows/changelog.yaml"):
        os.remove(".github/workflows/changelog.yaml")
    if os.path.exists(".github/run-changelog.mjs"):
        os.remove(".github/run-changelog.mjs")


def _update_clean_workflow(task_env: TaskEnv) -> None:
    if not task_env.use_docker:
        if os.path.exists(".github/workflows/clean.yaml"):
            os.remove(".github/workflows/clean.yaml")
        return
    if not os.path.exists(".github/workflows/clean.yaml"):
        with mra.Edit(".github/workflows/clean.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Clean docker hub tags",
                    "",
                    "on:",
                    "  delete:",
                    "  pull_request:",
                    "    types:",
                    "      - closed",
                    "",
                    "jobs:",
                    "  clean:",
                    "    runs-on: ubuntu-22.04",
                    "    name: Clean docker hub tags",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - uses: actions/checkout@v4",
                    "",
                    "      - uses: camptocamp/initialise-gopass-summon-action@v2",
                    "        with:",
                    "          ci-gpg-private-key: ${{secrets.CI_GPG_PRIVATE_KEY}}",
                    "          github-gopass-ci-token: ${{secrets.GOPASS_CI_GITHUB_TOKEN}}",
                    "          patterns: docker",
                    "",
                    '      - run: echo "${HOME}/.local/bin" >> ${GITHUB_PATH}',
                    "      - run: python3 -m pip install --user --requirement=ci/requirements.txt",
                    "",
                    "      - name: Clean Docker hub tags",
                    "        run: c2cciutils-clean",
                ]
            )
    with mra.EditYAML(".github/workflows/clean.yaml") as yaml:
        if task_env.gopass:
            gopass_init = False
            checkout_index = -1
            job_config = None
            for job in yaml["jobs"].values():
                for index, step in enumerate(job["steps"]):
                    if step.get("uses", "").startswith("actions/checkout@"):
                        checkout_index = index
                        job_config = job
                    if step.get("uses", "").startswith("camptocamp/initialise-gopass-summon-action@"):
                        gopass_init = True

            if not gopass_init:
                assert job_config is not None
                job_config["steps"].insert(
                    checkout_index + 1,
                    {
                        "uses": "camptocamp/initialise-gopass-summon-action@v2",
                        "with": {
                            "ci-gpg-private-key": "${{secrets.CI_GPG_PRIVATE_KEY}}",
                            "github-gopass-ci-token": task_env.token,
                        },
                    },
                )
                job_config["steps"].ca.items[checkout_index] = [
                    None,
                    None,
                    [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                    None,
                ]
                job_config["steps"].ca.items[checkout_index + 1] = [
                    None,
                    None,
                    [ruamel.yaml.CommentToken("\n\n", ruamel.yaml.error.CommentMark(0), None)],
                    None,
                ]
        else:
            gopass_index = -1
            for job in yaml["jobs"].values():
                for index, step in enumerate(job["steps"]):
                    if step.get("uses", "").startswith("camptocamp/initialise-gopass-summon-action@"):
                        gopass_index = index
            if gopass_index >= 0:
                for job in yaml["jobs"].values():
                    del job["steps"][gopass_index]

        for job in yaml["jobs"].values():
            for step in job["steps"]:
                if "c2cciutils-clean" in step.get("run", ""):
                    step["name"] = "Clean Docker hub tags"
                    if not task_env.gopass:
                        step.setdefault("env", {}).update(
                            {
                                "DOCKERHUB_PASSWORD": "${{ secrets.DOCKER_PASSWORD }}",
                                "DOCKERHUB_USERNAME": "${{ secrets.DOCKER_USERNAME }}",
                            }
                        )

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_delete_old_workflows_run_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/workflows/delete-old-workflow-run.yaml"):
        os.remove(".github/workflows/delete-old-workflow-run.yaml")
    if os.path.exists(".github/workflows/delete-old-workflows-run.yaml"):
        os.remove(".github/workflows/delete-old-workflows-run.yaml")


def safe_or(elements: list[str], prefix: str = "") -> str:
    if len(elements) == 0:
        return ""
    if len(elements) == 1:
        return elements[0]
    return "(" + f"\n{prefix}|| ".join(elements) + ")"


def _and(elements: list[str], prefix: str = "") -> str:
    elements = [e for e in elements if e]
    if len(elements) == 0:
        return ""
    return f"\n{prefix}&& ".join(elements)


def _update_pull_request_automation_workflow(task_env: TaskEnv) -> None:
    for file_ in (
        ".github/workflows/dependabot-auto-merge.yaml",
        ".github/workflows/auto-review.yaml",
        ".github/workflows/auto-merge.yaml",
        ".github/workflows/dependency-update-review.yaml",
        ".github/workflows/dependency-auto-review.yaml",
    ):
        if os.path.exists(file_):
            if os.path.exists(".github/workflows/pull-request-automation.yaml"):
                os.remove(file_)
            else:
                mra.run(
                    [
                        "git",
                        "mv",
                        file_,
                        ".github/workflows/pull-request-automation.yaml",
                    ]
                )
    if not os.path.exists(".github/workflows/pull-request-automation.yaml"):
        with mra.Edit(".github/workflows/pull-request-automation.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Auto reviews updates",
                    "",
                    "on:",
                    "  pull_request:",
                    "    types:",
                    "      - opened",
                    "      - reopened",
                    "",
                    "jobs:",
                    "  auto-merge:",
                    "    name: Auto reviews updates",
                    "    runs-on: ubuntu-22.04",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - uses: actions/github-script@v7",
                    "        with:",
                    "          script: |-",
                    "            github.rest.pulls.createReview({",
                    "              owner: context.repo.owner,",
                    "              repo: context.repo.repo,",
                    "              pull_number: context.payload.pull_request.number,",
                    "              event: 'APPROVE',",
                    "            })",
                    "    if: github.event.pull_request.user.login == 'renovate[bot]'",
                ]
            )
    with mra.EditYAML(".github/workflows/pull-request-automation.yaml") as yaml:
        task_env.config.value("dependencyAutoReviewUsers", ["renovate[bot]"])
        yaml["name"] = "Auto reviews pull requests from bots"
        yaml["on"] = {
            "pull_request": {"types": ["opened", "reopened"]},
        }
        yaml["name"] = "Auto reviews, merge and close pull requests"
        for job in yaml["jobs"].values():
            job["name"] = "Auto reviews pull requests from bots"
            if "if" in job:
                del job["if"]

            PRINT_EVENT = "Print event"
            PRINT_CONTEXT = "Print context"
            AUTO_REVIEW_GHCI_UPDATES = "Auto reviews GHCI updates"
            AUTO_REVIEW_RENOVATE_UPDATES = "Auto reviews Renovate updates"
            AUTO_REVIEW_AND_MERGE_DPKG_UPDATES = "Auto review and merge dpkg updates"
            AUTO_REVIEW_AND_MERGE_SNYK_AUTO_FIX = "Auto review and merge snyk auto fix"
            step_names = [
                PRINT_EVENT,
                PRINT_CONTEXT,
                AUTO_REVIEW_GHCI_UPDATES,
                AUTO_REVIEW_RENOVATE_UPDATES,
            ]

            old_step = {}
            for new_step_name in step_names:
                for step in job["steps"]:
                    if step.get("name") == new_step_name:
                        old_step[new_step_name] = step
                        break

            job["steps"] = [old_step.get(step, {"name": step}) for step in step_names]

            auto_review_and_merge_snyk_auto_fix_index = -1
            for index, step in enumerate(job["steps"]):
                if step["name"] == AUTO_REVIEW_AND_MERGE_SNYK_AUTO_FIX:
                    auto_review_and_merge_snyk_auto_fix_index = index
            if auto_review_and_merge_snyk_auto_fix_index >= 0:
                del job["steps"][auto_review_and_merge_snyk_auto_fix_index]

            auto_review_and_merge_dpkg_update_index = -1
            for index, step in enumerate(job["steps"]):
                if step["name"] == AUTO_REVIEW_AND_MERGE_DPKG_UPDATES:
                    auto_review_and_merge_dpkg_update_index = index
            if auto_review_and_merge_dpkg_update_index >= 0:
                del job["steps"][auto_review_and_merge_dpkg_update_index]

            for step in job["steps"]:
                if step["name"] == PRINT_EVENT:
                    step["run"] = 'echo "${GITHUB}" | jq'
                    step["env"] = {
                        "GITHUB": "${{ toJson(github) }}",
                    }
                if step["name"] == PRINT_CONTEXT:
                    if not step.get("uses", "").startswith("actions/github-script@"):
                        step["uses"] = "actions/github-script@v7"
                    step["with"] = {
                        "script": ruamel.yaml.scalarstring.LiteralScalarString(
                            "\n".join(["console.log(context);"])
                        )
                    }
                    if "if" in step:
                        del step["if"]
                    if "env" in step:
                        del step["env"]
                if step["name"] == AUTO_REVIEW_GHCI_UPDATES:
                    if not step.get("uses", "").startswith("actions/github-script@"):
                        step["uses"] = "actions/github-script@v7"
                    step["if"] = ruamel.yaml.scalarstring.LiteralScalarString(
                        _and(
                            [
                                "startsWith(github.head_ref, 'ghci/audit/')",
                                safe_or(
                                    [
                                        f"github.event.pull_request.user.login == 'geo-ghci-test[bot]'",
                                        f"github.event.pull_request.user.login == 'geo-ghci-int[bot]'",
                                        f"github.event.pull_request.user.login == 'geo-ghci[bot]'",
                                    ],
                                    "  ",
                                ),
                            ]
                        )
                    )
                    step["with"] = {
                        "script": ruamel.yaml.scalarstring.LiteralScalarString(
                            "\n".join(
                                [
                                    "github.rest.pulls.createReview({",
                                    "  owner: context.repo.owner,",
                                    "  repo: context.repo.repo,",
                                    "  pull_number: context.payload.pull_request.number,",
                                    "  event: 'APPROVE',",
                                    "})",
                                ]
                            )
                        )
                    }
                if step["name"] == AUTO_REVIEW_RENOVATE_UPDATES:
                    if not step.get("uses", "").startswith("actions/github-script@"):
                        step["uses"] = "actions/github-script@v7"
                    step["if"] = ruamel.yaml.scalarstring.LiteralScalarString(
                        f"github.event.pull_request.user.login == 'renovate[bot]'",
                    )
                    step["with"] = {
                        "script": ruamel.yaml.scalarstring.LiteralScalarString(
                            "\n".join(
                                [
                                    "github.rest.pulls.createReview({",
                                    "  owner: context.repo.owner,",
                                    "  repo: context.repo.repo,",
                                    "  pull_number: context.payload.pull_request.number,",
                                    "  event: 'APPROVE',",
                                    "})",
                                ]
                            )
                        )
                    }
                auto_review_merge_script = "\n".join(
                    [
                        "github.rest.pulls.createReview({",
                        "  owner: context.repo.owner,",
                        "  repo: context.repo.repo,",
                        "  pull_number: context.payload.pull_request.number,",
                        "  event: 'APPROVE',",
                        "});",
                        "github.graphql(`",
                        "  mutation {",
                        "    enablePullRequestAutoMerge(input: {",
                        '      pullRequestId: "${context.payload.pull_request.node_id}",',
                        "      mergeMethod: SQUASH,",
                        "    }) {",
                        "      pullRequest {",
                        "        autoMergeRequest {",
                        "          enabledAt",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "`)",
                    ]
                )

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_pull_request_checks_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/workflows/pr-checks.yaml"):
        os.remove(".github/workflows/pr-checks.yaml")
    if os.path.exists(".github/workflows/test_url.yaml"):
        os.remove(".github/workflows/test_url.yaml")


def _update_backport_workflow(task_env: TaskEnv) -> None:
    if not task_env.has_stabilization_branches:
        if os.path.exists(".github/workflows/backport.yaml"):
            os.remove(".github/workflows/backport.yaml")
        return
    if not os.path.exists(".github/workflows/backport.yaml"):
        with mra.Edit(".github/workflows/backport.yaml") as text:
            text.data = "\n".join(
                [
                    "name: Backport",
                    "",
                    "on:",
                    "  pull_request:",
                    "    types:",
                    "      - closed",
                    "      - labeled",
                    "",
                    "env:",
                    "  HAS_SECRETS: ${{ secrets.HAS_SECRETS }}",
                    "",
                    "jobs:",
                    "  backport:",
                    "    runs-on: ubuntu-22.04",
                    "    name: Backport",
                    "    timeout-minutes: 5",
                    "",
                    "    steps:",
                    "      - uses: camptocamp/backport-action@master",
                    "        with:",
                    "          token: ${{ secrets.GOPASS_CI_GITHUB_TOKEN }}",
                    "        if: env.HAS_SECRETS == 'HAS_SECRETS'",
                ]
            )
    with mra.EditYAML(".github/workflows/backport.yaml") as yaml:
        for job in yaml["jobs"].values():
            for step in job["steps"]:
                if step.get("uses", "") == "camptocamp/backport-action@master":
                    step.setdefault("with", {})["token"] = task_env.token

        if not task_env.on_stabilization_branches or yaml.is_modified():
            _canonicalize_workflow(yaml)


def _update_rebuild_workflow(task_env: TaskEnv) -> None:
    if os.path.exists(".github/workflows/rebuild.yaml"):
        should_be_removed = False
        with mra.EditYAML(".github/workflows/rebuild.yaml") as yaml:
            for job in yaml["jobs"].values():
                if "master" in job.get("strategy", {}).get("matrix", {}).get("branch", []):
                    job["strategy"]["matrix"]["branch"].remove("master")
                should_be_removed = not job["strategy"]["matrix"]["branch"]

                for step in job["steps"]:
                    if step.get("run", "") == "c2cciutils-checks":
                        if not task_env.gopass:
                            env = step.setdefault("env", {})
                            env["SNYK_TOKEN"] = "${{ secrets.SNYK_TOKEN }}"  # nosec

                    if "c2cciutils-publish" in step.get("run", ""):
                        if not task_env.gopass:
                            step.setdefault("env", {}).update(
                                {
                                    "GITHUB_TOKEN": task_env.token,
                                    "SNYK_TOKEN": "${{ secrets.SNYK_TOKEN }}",
                                }
                            )
                        elif "env" in step:
                            if "GITHUB_TOKEN" in step["env"]:
                                del step["env"]["GITHUB_TOKEN"]
                            if "SNYK_TOKEN" in step["env"]:
                                del step["env"]["SNYK_TOKEN"]
                            if not step["env"]:
                                del step["env"]

            if not task_env.on_stabilization_branches or yaml.is_modified():
                _canonicalize_workflow(yaml)

        if should_be_removed:
            os.remove(".github/workflows/rebuild.yaml")


def _update_pyproject_toml(task_env: TaskEnv) -> None:
    """
    Add or update the Poetry extensions to the pyproject.toml file.
    """

    poetry_version = version.parse("0.0.0")
    for requirements_file_name in ("requirements.txt", "ci/requirements.txt"):
        if os.path.exists(requirements_file_name):
            with mra.Edit(requirements_file_name) as requirements_txt:
                for line in requirements_txt.data.splitlines():
                    if line.startswith("poetry=="):
                        poetry_version = version.parse(line.split("==")[1])
                        break

    if poetry_version >= version.parse("1.3.0"):
        for pyproject_filename in ("pyproject.toml", "app/pyproject.toml", "api/pyproject.toml"):
            if os.path.exists(pyproject_filename):
                with mra.EditTOML(pyproject_filename) as pyproject:
                    if "requires" in pyproject.get("build-system", {}) and "python" in pyproject.get(
                        "tool", {}
                    ).get("poetry", {}).get("dependencies", {}):
                        # tool.mypy.python_version as string
                        if (
                            "tool" in pyproject
                            and "mypy" in pyproject["tool"]
                            and "python_version" in pyproject["tool"]["mypy"]
                        ):
                            pyproject["tool"]["mypy"]["python_version"] = str(
                                "3.10"
                                if pyproject["tool"]["mypy"]["python_version"] == 3.1
                                else pyproject["tool"]["mypy"]["python_version"]
                            )

                        for plugin in (
                            "poetry-dynamic-versioning",
                            "poetry-plugin-tweak-dependencies-version",
                            "poetry-plugin-drop-python-upper-constraint",
                        ):
                            if plugin not in pyproject["build-system"]["requires"]:
                                pyproject.data["build-system"]["requires"].append(plugin)
                        for requirements_file_name in ("requirements.txt", "ci/requirements.txt"):
                            if os.path.exists(requirements_file_name):
                                with mra.Edit(requirements_file_name) as requirements_txt:
                                    if "poetry" in requirements_txt.data:
                                        for plugin, plugin_version in (
                                            ("poetry-dynamic-versioning", "1.1.0"),
                                            ("poetry-plugin-export", "1.6.0"),
                                            ("poetry-plugin-tweak-dependencies-version", "1.5.2"),
                                            ("poetry-plugin-drop-python-upper-constraint", "0.1.0"),
                                        ):
                                            if (
                                                f"{plugin}==" not in requirements_txt.data
                                                and f"{plugin}[" not in requirements_txt.data
                                            ):
                                                requirements_txt.data += f"{plugin}=={plugin_version}\n"

                        poetry_dynamic_versioning = pyproject.setdefault("tool", {}).setdefault(
                            "poetry-dynamic-versioning", {}
                        )
                        poetry_dynamic_versioning.setdefault("enable", True)
                        poetry_dynamic_versioning.setdefault("vcs", "git")
                        poetry_dynamic_versioning.setdefault("pattern", "^(?P<base>\\d+(\\.\\d+)*)")
                        if "style" in poetry_dynamic_versioning:
                            del poetry_dynamic_versioning["style"]
                        poetry_dynamic_versioning["format-jinja"] = tomlkit.items.String.from_raw(
                            "\n".join(
                                [
                                    "",
                                    '{%- if env.get("VERSION_TYPE") == "version_branch" -%}',
                                    '{{serialize_pep440(bump_version(base, 1 if env.get("IS_MASTER") == "TRUE" else 2), dev=distance)}}',
                                    "{%- elif distance == 0 -%}",
                                    "{{serialize_pep440(base)}}",
                                    "{%- else -%}",
                                    "{{serialize_pep440(bump_version(base), dev=distance)}}",
                                    "{%- endif -%}",
                                    "",
                                ]
                            ),
                            tomlkit.items.StringType.MLB,
                        )
                        poetry_plugin_tweak_dependencies_version = pyproject.setdefault(
                            "tool", {}
                        ).setdefault("poetry-plugin-tweak-dependencies-version", {})
                        poetry_plugin_tweak_dependencies_version.setdefault("default", "present")


def _update_renovate_config(task_env: TaskEnv) -> None:
    if task_env.c2cciutils_version >= version.parse("1.6.0"):
        if not os.path.exists(".github/renovate.json5"):
            with mra.Edit(".github/renovate.json5") as renovate_config:
                renovate_config.data = "{}"

    with mra.EditRenovateConfigV2() as renovate_config:
        renovate_config.setdefault("extends", ["config:base"])

        if renovate_config.get("extends", []) == ["config:base"]:
            renovate_config["extends"] = [
                ":dependencyDashboard",
                "group:monorepos",
                "group:recommended",
                "replacements:all",
                "workarounds:all",
            ]

        renovate_config.setdefault("timezone", "Europe/Zurich")
        renovate_config["schedule"] = "after 5pm on the first day of the month"
        renovate_config.setdefault("labels", ["dependencies"])
        renovate_config.setdefault("separateMajorMinor", True)
        renovate_config.setdefault("separateMinorPatch", True)
        renovate_config.setdefault("prHourlyLimit", 0)
        renovate_config.setdefault("prConcurrentLimit", 0)
        renovate_config.setdefault(
            "lockFileMaintenance",
            {
                "enabled": True,
                "automerge": True,
                "schedule": "after 5pm on the first day of the month",
            },
        )

        # Fix escapes
        for regex_manager in renovate_config.data.get("regexManagers", []):
            file_match = regex_manager["fileMatch"]
            match_strings = regex_manager["matchStrings"]
            if isinstance(file_match, mra.JSON5RowAttribute):
                if re.search(
                    r"\\*.pre-commit-config\\*.yaml",
                    json5.dumps(file_match.value),
                ):
                    file_match.value = [f'^{re.escape(".pre-commit-config.yaml")}$']
                if re.search(
                    r"ci/dpkg-versions\\*.yaml",
                    json5.dumps(file_match.value),
                ):
                    file_match.value = [f'^{re.escape("ci/dpkg-versions.yaml")}$']
                # if re.search(
                #    r"ci/config\\*.yaml",
                #    json5.dumps(file_match.value),
                # ):
                #    file_match.value = [f'^{re.escape("ci/config.yaml")}$']
            if isinstance(match_strings, mra.JSON5List) and re.search(
                r"\.\*https://raw\\*.githubusercontent\\*.com/(\?<depName>[^\\*s]+)/(\?<currentValue>[0-9\\*.]\+)/\.\*",
                json5.dumps(regex_manager["matchStrings"][0].value),
            ):
                regex_manager["matchStrings"][
                    0
                ].value = (
                    r".*https://raw\.githubusercontent\.com/(?<depName>[^\s]+)/(?<currentValue>[0-9\.]+)/.*"
                )

        renovate_config["schedule"] = "after 5pm on the first day of the month"
        if os.path.exists(".pre-commit-config.yaml"):
            preCommit = mra.JSON5RowDict()
            preCommit.comment = ["Do updates on pre-commit config"]
            preCommit.value = {"enabled": True}

            renovate_config.add_regex_manager(
                {
                    "fileMatch": [f'^{re.escape(".pre-commit-config.yaml")}$'],
                    "matchStrings": [
                        " +- '?(?<depName>[^' @=]+)(@|==)(?<currentValue>[^' @=]+)'? # (?<datasource>.+)"
                    ],
                },
                ["Do updates on pre-commit additional dependencies"],
            )
        # No more do update on packages update (trigger a rebuild)
        renovate_config.remove_regex_manager(
            {
                "fileMatch": [f'^{re.escape("ci/dpkg-versions.yaml")}$'],
                "matchStrings": [r" *(?<depName>[^'\s]+): '?(?<currentValue>[^'\s/]*[0-9][^'\s/]*)'?"],
                "datasourceTemplate": "repology",
                "versioningTemplate": "loose",
            },
            ["Do update on packages update (trigger a rebuild)"],
        )
        # Do update on the schema present in the ci/config.yaml
        renovate_config.add_regex_manager(
            {
                "fileMatch": [f'^{re.escape("ci/config.yaml")}$'],
                "matchStrings": [
                    r".*https://raw\.githubusercontent\.com/(?<depName>[^\s]+)/(?<currentValue>[0-9\.]+)/.*",
                ],
                "datasourceTemplate": "github-tags",
            },
            ["Do update on the schema present in the ci/config.yaml"],
        )
        # Support the 4 parts of shellcheck-py version
        renovate_config.add_package_rule(
            {
                "matchPackageNames": ["shellcheck-py/shellcheck-py"],
                "versioning": "regex:^v(?<major>\\d+)\\.(?<minor>\\d+)\\.(?<patch>\\d+)\\.(?<build>\\d+)$",
            },
            ["Support the 4 parts of shellcheck-py version with a v prefix"],
        )
        renovate_config.add_package_rule(
            {
                "matchDepTypes": ["devDependencies"],
                "automerge": True,
            },
            ["Auto merge the dev dependency update"],
        )
        renovate_config.add_package_rule(
            {
                "matchUpdateTypes": ["patch"],
                "groupName": "all patch versions",
                "automerge": True,
            },
            ["Group and auto merge the patch updates"],
            ["matchUpdateTypes", "groupName"],
        )
        renovate_config.add_package_rule(
            {
                "matchUpdateTypes": ["minor"],
                "groupName": "all minor versions",
                "automerge": True,
            },
            ["Group and auto merge the minor updates"],
            ["matchUpdateTypes", "groupName"],
        )
        if task_env.has_stabilization_branches:
            renovate_config.add_package_rule(
                {
                    "matchBaseBranches": task_env.config.value(
                        "matchStabilizationBranches", [r"/^[0-9]+\.[0-9]+$/"]
                    ),
                    "matchUpdateTypes": [
                        "major",
                        "minor",
                        "pin",
                        "digest",
                        "lockFileMaintenance",
                        "rollback",
                        "bump",
                    ],
                    "enabled": False,
                },
                ["Accept only the patch on stabilization branches"],
                ["matchUpdateTypes"],
            )

        if task_env.use_python:
            renovate_config.add_package_rule(
                {
                    "matchPackageNames": ["poetry", "pip"],
                    "matchPackagePrefixes": ["poetry-"],
                    "groupName": "Poetry",
                    "automerge": True,
                },
                ["Group Poetry packages"],
            )
        if task_env.use_docker and task_env.has_stabilization_branches:
            # No more update dpkg versions every day
            renovate_config.remove_package_rule(
                {
                    "groupName": "dpkg",
                },
                ["Update dpkg versions at any time"],
            )

        renovate_config.remove_package_rule(
            {"matchDatasources": ["github-actions", "pre-commit"], "automerge": True},
            ["Auto merge the GitHub action and pre-commit updates"],
        )
        renovate_config.add_package_rule(
            {
                "matchFileNames": [".github/**", ".pre-commit-config.yaml", "ci/**"],
                "groupName": "CI dependencies",
                "automerge": True,
            },
            ["Group and auto merge the CI dependencies"],
        )

        for package_rule in renovate_config.data.get("packageRules", []):
            if "matchPackageNames" in package_rule:
                package_rule["matchDepNames"] = package_rule["matchPackageNames"]
                del package_rule["matchPackageNames"]


def _update_config(task_env: TaskEnv) -> None:
    if task_env.has_config and task_env.c2cciutils_version >= version.parse("1.6.0"):
        with mra.EditYAML("ci/config.yaml") as config:
            if "checks" in config:
                del config["checks"]
            to_delete = len(config.keys()) == 0
        if to_delete:
            os.remove("ci/config.yaml")

    if task_env.use_docker:
        if not os.path.exists("ci/dpkg-versions.yaml"):
            with open("ci/dpkg-versions.yaml", "w", encoding="utf-8") as dpkg_versions:
                dpkg_versions.write("{}")
            with mra.EditYAML("ci/dpkg-versions.yaml") as dpkg_versions:
                c2cciutils_config = c2cciutils.get_config()
                for image in c2cciutils_config.get("publish", {}).get("docker", {}).get("images", []):
                    for tag in image.get("tags", ["{version}"]):
                        try:
                            image_name = f"{image['name']}:{tag.format(version='master')}"
                            mra.run(["docker", "pull", image_name])
                            success, versions = c2cciutils.lib.docker.get_dpkg_packages_versions(image_name)
                            if success:
                                dpkg_versions[f"{image['name']}:{tag.format(version='latest')}"] = {
                                    k: str(v) for k, v in versions.items()
                                }
                        except SystemExit:
                            print(f"Error while getting dpkg versions for {image['name']}:{tag}")
                        except Exception as e:
                            print(f"Error while getting dpkg versions for {image['name']}:{tag}: {e}")


def _update_pre_commit_config(task_env: TaskEnv) -> None:
    if os.path.exists(".pre-commit-config.yaml"):
        with mra.EditPreCommitConfig() as pre_commit_config:
            pre_commit_config.add_repo("https://github.com/sbrunner/jsonschema-validator")
            pre_commit_config.add_hook(
                "https://github.com/sbrunner/jsonschema-validator",
                {
                    "id": "jsonschema-validator",
                    "files": pre_commit_config.create_files_regex(["ci/config\\.yaml"]),
                },
                True,
            )

            # Do a spell check on the found schemas
            schemas = []
            for files_ in ("*.schema.json", "schema.json", "schema-*.json"):
                schemas += [
                    f
                    for f in mra.run(["git", "ls-files", files_], stdout=subprocess.PIPE).stdout.split("\n")
                    if f
                ]
                # Get all the schemas files
                schemas += [
                    f
                    for f in mra.run(
                        ["git", "ls-files", f"**/{files_}"], stdout=subprocess.PIPE
                    ).stdout.split("\n")
                    if f
                ]

            if schemas:
                pre_commit_config.add_repo("https://github.com/mheap/json-schema-spell-checker", "master")
                pre_commit_config.add_hook(
                    "https://github.com/mheap/json-schema-spell-checker",
                    {
                        "id": "json-schema-spell-checker",
                        "files": pre_commit_config.create_files_regex([re.escape(f) for f in schemas]),
                        "args": [
                            "--fields=description,title",
                            "--spelling=.github/spell-ignore-words.txt",
                            "--ignore-numbers",
                            "--ignore-acronyms",
                            "--en-us",
                        ],
                    },
                )
    _update_pre_commit_config_stabilization_branches(task_env)


def _update_pre_commit_config_stabilization_branches(task_env: TaskEnv) -> None:
    del task_env

    if os.path.exists(".pre-commit-config.yaml"):
        with mra.EditPreCommitConfig() as pre_commit_config:
            for repo in pre_commit_config.data["repos"]:
                # Fucking branch renaming
                if (
                    repo.get("repo", "") == "https://github.com/mheap/json-schema-spell-checker"
                    and repo["rev"] == "master"
                ):
                    repo["rev"] = "main"


def _get_env() -> TaskEnv:
    config = Config()

    use_helm = config.enabled(
        "helm", os.path.exists("Chart.yaml") or os.path.exists("test/helmchart/Chart.yaml")
    )

    gopass = config.enabled(
        "gopass",
        "no-gopass" not in config.repo.get("types", [])
        and (config.repo["name"].startswith("camptocamp/") or config.repo["name"].startswith("mapfish/")),
    )
    # Get the string we used in the workflow to get the GitHub token to be used
    token = config.value(
        "github_token_secret", "${{ secrets.GOPASS_CI_GITHUB_TOKEN }}" if gopass else "${{ secrets.TOKEN }}"
    )

    # This is to implement a workaround of this issue: https://sourceforge.net/p/ruamel-yaml/tickets/480/
    has_config = False
    if os.path.exists("ci/config.yaml"):
        with open("ci/config.yaml", encoding="utf-8") as f:
            has_config = py_yaml.load(f.read(), Loader=py_yaml.SafeLoader)

    # Get the version of c2cciutils
    c2cciutils_version = version.parse("1.6.0")
    set_c2cciutils_version = False
    if os.path.exists("ci/requirements.txt"):
        with mra.Edit("ci/requirements.txt") as requirements_txt:
            requirements = [
                r
                for r in requirements_txt.data.split("\n")
                if r.startswith("c2cciutils==") or r.startswith("c2cciutils[")
            ]
            if len(requirements) == 1:
                c2cciutils_version_string = requirements[0].split("==")[1]
                if c2cciutils_version_string.endswith(".*"):
                    c2cciutils_version_string = c2cciutils_version_string[:-2]
                c2cciutils_version = version.parse(c2cciutils_version_string)
                set_c2cciutils_version = True
    c2cciutils_version_config = config.value("c2cciutils_version")
    if c2cciutils_version_config:
        if c2cciutils_version_config == "master":
            c2cciutils_version = version.parse("1.6.0")
            set_c2cciutils_version = False
        else:
            c2cciutils_version = version.parse(c2cciutils_version_config)
            set_c2cciutils_version = True

    use_python = False
    for pyproject_filename in ("pyproject.toml", "app/pyproject.toml", "api/pyproject.toml"):
        if os.path.exists(pyproject_filename):
            with mra.EditTOML(pyproject_filename) as pyproject:
                use_python = "project" in pyproject or "build-system" in pyproject
    use_python = config.enabled("python", use_python)

    use_pypi = config.enabled("pypi", use_python and "no-pypi" not in config.repo.get("type", []))
    use_docker = config.enabled(
        "docker",
        (os.path.exists("Dockerfile") or os.path.exists("app/Dockerfile") or os.path.exists("api/Dockerfile"))
        and "no-docker" not in config.repo.get("type", []),
    )

    stabilization_branches = mra.get_stabilization_branches(config.repo)

    return TaskEnv(
        c2cciutils_version,
        set_c2cciutils_version,
        use_python,
        use_pypi,
        use_docker,
        use_helm,
        has_config,
        config.arguments.on_stabilization_branches or len(stabilization_branches) > 0,
        config.arguments.on_stabilization_branches and len(stabilization_branches) > 0,
        gopass,
        token,
        config,
    )


def _ghci_updates(task_env: TaskEnv) -> None:
    if (
        task_env.use_helm
        and not os.path.exists(".github/ghci.yaml")
        and not task_env.on_stabilization_branches
    ):
        with open(".github/ghci.yaml", "w", encoding="utf-8") as ghci:
            ghci.write(
                """# yaml-language-server: $schema=https://geoservices-int.camptocamp.com/github/schema.json

profile: helm
"""
            )


def _do() -> None:
    task_env = _get_env()
    print(f"Task environment: {task_env}")

    for name, task in (
        ("create-labels", _create_labels),
        ("set-schema-config", _set_schema_config),
        ("update-changelog-workflow", _update_changelog_workflow),
        ("update-clean-workflow", _update_clean_workflow),
        ("update-dependency-auto-review-workflow", _update_pull_request_automation_workflow),
        ("update-pull-request-checks-workflow", _update_pull_request_checks_workflow),
        ("update-backport-workflow", _update_backport_workflow),
        ("update-main-workflow", _update_main_workflow),
        ("update-ghci", _ghci_updates),
    ):
        if task_env.config.enabled(name, True):
            task(task_env)
    if task_env.on_stabilization_branches:
        for file_ in (
            ".github/workflows/delete-old-workflow-run.yaml",
            ".github/workflows/delete-old-workflows-run.yaml",
            ".github/renovate.json5",
        ):
            if os.path.exists(file_):
                os.remove(file_)
        for file_ in glob.glob(".github/workflows/audit*.yaml"):
            os.remove(file_)
        for file_ in glob.glob(".github/workflows/rebuild*.yaml"):
            os.remove(file_)

        if not os.path.exists("ci/config.yaml"):
            with open("ci/config.yaml", "w", encoding="utf-8") as config:
                config.write("{}")

        with mra.EditYAML("ci/config.yaml") as config:
            if config.get("checks") is not False:
                # config.setdefault("checks", {})["codespell"] = False
                if task_env.c2cciutils_version.major == 1 and task_env.c2cciutils_version.minor <= 3:
                    config.setdefault("checks", {})["required_workflows"] = False

        for name, task in (("update-pre-commit-config", _update_pre_commit_config_stabilization_branches),):
            if task_env.config.enabled(name, True):
                task(task_env)
    else:
        for name, task in (
            ("upgrade-ubuntu", _upgrade_ubuntu),
            ("update-audit-workflow", _update_audit_workflow),
            ("update-delete-old-workflow-run-workflow", _update_delete_old_workflows_run_workflow),
            ("update-rebuild-workflow", _update_rebuild_workflow),
            ("update-pyproject-toml", _update_pyproject_toml),
            ("update-renovate-config", _update_renovate_config),
            ("update-config", _update_config),
            ("update-pre-commit-config", _update_pre_commit_config),
        ):
            if task_env.config.enabled(name, True):
                task(task_env)


if __name__ == "__main__":
    # edit the file /home/sbrunner/workspace/docker-vim/.github/workflows/changelog.yaml
    # with mra.EditYAML("/home/sbrunner/workspace/docker-vim/.github/workflows/audit.yaml") as e:
    #    _canonicalize_workflow(e)
    # with mra.EditYAML("/home/sbrunner/workspace/docker-vim/.github/workflows/changelog.yaml") as e:
    #    _canonicalize_workflow(e)
    # exit(0)

    os.environ["IGNORE_CONFIG_ERROR"] = "true"

    mra.main(
        _do,
        # pull_request_on_stabilization_branches
        # pull_request_title
        # pull_request_body
        # branch
        # pull_request_branch_prefix
        config={
            "branch": "c2cciutils-upgrade",
            "pull_request_branch_prefix": "c2cciutils-upgrade-",
            "pull_request_title": "CI updates",
            "pull_request_body": "This is done by the automated script named " + os.path.basename(__file__),
        },
        description="Update the repository for c2cciutils version 1.6, the will also fix the errors he found",
    )
